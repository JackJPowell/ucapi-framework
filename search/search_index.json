{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"UCAPI Framework","text":"<p>A framework for building Unfolded Circle Remote integrations that handles the repetitive parts of integration development so you can focus on what's important.</p>"},{"location":"#what-this-solves","title":"What This Solves","text":"<p>Building an Unfolded Circle Remote integration typically involves:</p> <ul> <li>Writing 200+ lines of setup flow routing logic</li> <li>Manually managing configuration updates and persistence</li> <li>Implementing device lifecycle management (connect/disconnect/reconnect)</li> <li>Wiring up Remote event handlers</li> <li>Managing global state for devices and entities</li> <li>Handling entity registration and state synchronization</li> </ul> <p>This framework provides tested implementations of all these patterns, reducing a simple integration from ~1500 lines of boilerplate to ~400 lines of device-specific code. It even adds features, like backup and restore, for free.</p>"},{"location":"#core-features","title":"Core Features","text":""},{"location":"#standard-setup-flow-with-extension-points","title":"Standard Setup Flow with Extension Points","text":"<p>The setup flow handles the common pattern: configuration mode \u2192 discovery/manual entry \u2192 device selection. But every integration has unique needs, so there are extension points at key moments:</p> <ul> <li>Pre-discovery screens - Collect API credentials or server addresses before running discovery</li> <li>Post-selection screens - Gather device-specific settings after the user picks a device</li> <li>Custom discovery fields - Add extra fields to the discovery screen (zones, profiles, etc.)</li> </ul> <p>The framework handles all the routing, state management, duplicate checking, and configuration persistence. You just implement the screens you need.</p> <p>Reduction</p> <p>Setup flow code goes from ~200 lines to ~50 lines.</p>"},{"location":"#device-connection-patterns","title":"Device Connection Patterns","text":"<p>Five base classes cover the common connection patterns:</p> StatelessHTTPDevicePollingDeviceWebSocketDeviceExternalClientDevicePersistentConnectionDevice <p>For REST APIs. You implement <code>verify_connection()</code> to test reachability. No connection management needed.</p> <p>For devices that need periodic state checks. You set a poll interval and implement <code>poll_device()</code>. Automatic reconnection on errors.</p> <p>For WebSocket connections. You implement <code>create_websocket()</code> and <code>handle_message()</code>. Framework manages the connection lifecycle, reconnection, and cleanup.</p> <p>For third-party libraries that manage their own connections. You implement <code>create_client()</code>, <code>connect_client()</code>, and <code>check_client_connected()</code>. Framework provides watchdog monitoring and auto-reconnection.</p> <p>For TCP, serial, or custom protocols. You implement <code>establish_connection()</code>, <code>maintain_connection()</code>, and <code>close_connection()</code>. Framework handles the receive loop and error recovery.</p> <p>All connection management, error handling, reconnection logic, and cleanup happens automatically.</p> <p>Reduction</p> <p>Device implementation goes from ~100 lines of connection boilerplate to ~30 lines of business logic.</p>"},{"location":"#configuration-management","title":"Configuration Management","text":"<p>Configuration is just a dataclass. The framework handles JSON serialization, CRUD operations, and persistence:</p> <pre><code>from dataclasses import dataclass\nfrom ucapi_framework import BaseConfigManager\n\n@dataclass\nclass MyDeviceConfig:\n    device_id: str\n    name: str\n    host: str\n\nconfig = BaseConfigManager(\"config.json\", MyDeviceConfig)\n</code></pre> <p>You get full CRUD operations: <code>add_or_update()</code>, <code>get()</code>, <code>remove()</code>, <code>all()</code>, <code>clear()</code>. Plus automatic backup/restore functionality for free. The framework handles all the file I/O, error handling, and atomic writes.</p> <p>Full type safety means IDE autocomplete works everywhere. No more dict manipulation or manual JSON handling.</p> <p>Reduction</p> <p>Configuration management goes from ~80 lines to ~15 lines.</p>"},{"location":"#driver-integration","title":"Driver Integration","text":"<p>The driver coordinates everything - device lifecycle, entity management, and Remote events. Most integrations work with just the defaults - no overrides needed!</p> <p>The framework provides sensible defaults for:</p> <ul> <li><code>create_entities()</code> - Creates one entity per entity type automatically</li> <li><code>map_device_state()</code> - Maps common state strings (ON, OFF, PLAYING, etc.)</li> <li><code>device_from_entity_id()</code> - Parses standard entity ID format</li> <li><code>get_entity_ids_for_device()</code> - Queries and filters entities by device</li> </ul> <p>Override only what you need: Custom state enums? Override <code>map_device_state()</code>. Conditional entity creation? Override <code>create_entities()</code>. Custom entity ID format? Override <code>device_from_entity_id()</code> too.</p> <p>Everything else is automatic. The framework handles Remote connection events (connect, disconnect, standby), entity subscriptions, device lifecycle management, and state synchronization.</p> <p>Device events (like state changes) automatically propagate to entity state updates. The framework maintains the connection between your devices and your remote.</p> <p>Reduction</p> <p>Driver code goes from ~300 lines to ~50 lines (or less!).</p>"},{"location":"#discovery-optional","title":"Discovery (Optional)","text":"<p>If your devices support network discovery, the framework provides implementations for common protocols:</p> Discovery Class Use Case SSDPDiscovery UPnP/SSDP devices SDDPDiscovery SDDP devices (Samsung TVs) MDNSDiscovery mDNS/Bonjour devices NetworkScanDiscovery Active network scanning BaseDiscovery Custom discovery (implement <code>discover()</code>) <p>All discovery classes handle the protocol details, timeouts, and error handling. Dependencies are lazy-loaded, so you only install what you use.</p>"},{"location":"#architecture","title":"Architecture","text":"<p>The framework is layered:</p> <pre><code>graph TD\n    A[Your Integration] --&gt; B[BaseIntegrationDriver]\n    B --&gt; C[Device Interfaces]\n    C --&gt; D[Setup Flow + Config Manager]\n\n    style A fill:#e1f5ff\n    style B fill:#b3e5fc\n    style C fill:#81d4fa\n    style D fill:#4fc3f7\n</code></pre> <p>Each layer handles its responsibility and provides clean extension points. You only touch the top layer.</p>"},{"location":"#type-safety","title":"Type Safety","text":"<p>The framework uses bounded generics (<code>DeviceT</code>, <code>ConfigT</code>) so your IDE knows exactly what types you're working with:</p> <pre><code>class MyDriver(BaseIntegrationDriver[MyDevice, MyDeviceConfig]):\n    def get_device(self, device_id: str) -&gt; MyDevice | None:\n        device = super().get_device(device_id)\n        # IDE knows device is MyDevice, full autocomplete available\n</code></pre> <p>No casting, no generic types, just full type safety throughout.</p>"},{"location":"#real-world-example","title":"Real-World Example","text":"<p>See the PSN integration in this repository:</p> File Before After <code>driver.py</code> 300 lines 90 lines <code>psn.py</code> 240 lines 140 lines <code>setup_flow.py</code> 250 lines 50 lines <code>config.py</code> 95 lines 15 lines Total 885 lines 295 lines <p>And the new code is type-safe, testable, and maintainable.</p>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.11+</li> <li>ucapi</li> <li>pyee</li> </ul> <p>Optional (only if you use them):</p> <ul> <li>aiohttp (for HTTP devices)</li> <li>websockets (for WebSocket devices)</li> <li>ssdpy (for SSDP discovery)</li> <li>sddp-discovery-protocol (for SDDP discovery)</li> <li>zeroconf (for mDNS discovery)</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install ucapi-framework\n</code></pre> <p>Or with uv:</p> <pre><code>uv add ucapi-framework\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Check out the Getting Started guide to build your first integration in minutes!</p>"},{"location":"#license","title":"License","text":"<p>Mozilla Public License Version 2.0</p>"},{"location":"contributing/","title":"Contributing Tests to ucapi-framework","text":""},{"location":"contributing/#quick-guide-to-adding-new-tests","title":"Quick Guide to Adding New Tests","text":""},{"location":"contributing/#1-choose-the-right-test-file","title":"1. Choose the Right Test File","text":"<ul> <li>config.py changes \u2192 <code>tests/test_config.py</code></li> <li>device.py changes \u2192 <code>tests/test_device.py</code></li> <li>driver.py changes \u2192 <code>tests/test_driver.py</code></li> <li>setup.py changes \u2192 <code>tests/test_setup.py</code></li> <li>discovery.py changes \u2192 <code>tests/test_discovery.py</code></li> </ul>"},{"location":"contributing/#2-follow-the-test-naming-convention","title":"2. Follow the Test Naming Convention","text":"<pre><code>def test_&lt;what_is_being_tested&gt;_&lt;expected_behavior&gt;(self, fixtures):\n    \"\"\"Test that &lt;describe the test in plain English&gt;.\"\"\"\n    # Arrange\n    # Act\n    # Assert\n</code></pre> <p>Examples: - <code>test_device_connects_successfully</code> - <code>test_config_manager_handles_invalid_json</code> - <code>test_driver_updates_entity_state_on_device_event</code></p>"},{"location":"contributing/#3-use-existing-fixtures","title":"3. Use Existing Fixtures","text":"<p>Available fixtures in <code>conftest.py</code>: - <code>temp_config_dir</code> - Temporary directory for config files - <code>event_loop</code> - Async event loop - <code>sample_device</code> - Sample device configuration - <code>sample_devices</code> - List of device configurations - <code>mock_api</code> - Mock IntegrationAPI - <code>mock_device_config</code> - Mock device configuration</p>"},{"location":"contributing/#4-test-structure-template","title":"4. Test Structure Template","text":"<pre><code>class TestNewFeature:\n    \"\"\"Tests for new feature.\"\"\"\n\n    def test_basic_functionality(self, fixture):\n        \"\"\"Test the basic case works.\"\"\"\n        # Arrange\n        obj = SomeClass(fixture)\n\n        # Act\n        result = obj.do_something()\n\n        # Assert\n        assert result == expected_value\n\n    def test_error_handling(self, fixture):\n        \"\"\"Test that errors are handled gracefully.\"\"\"\n        obj = SomeClass(fixture)\n\n        with pytest.raises(ValueError, match=\"expected error\"):\n            obj.do_something_invalid()\n\n    @pytest.mark.asyncio\n    async def test_async_operation(self, fixture):\n        \"\"\"Test async functionality.\"\"\"\n        obj = SomeClass(fixture)\n\n        result = await obj.async_method()\n\n        assert result is not None\n</code></pre>"},{"location":"contributing/#5-testing-async-code","title":"5. Testing Async Code","text":"<p>Always use <code>@pytest.mark.asyncio</code> decorator:</p> <pre><code>@pytest.mark.asyncio\nasync def test_device_connects(self, mock_device_config, event_loop):\n    \"\"\"Test device connection.\"\"\"\n    device = MyDevice(mock_device_config, loop=event_loop)\n\n    await device.connect()\n\n    assert device.connected is True\n</code></pre>"},{"location":"contributing/#6-mocking-external-dependencies","title":"6. Mocking External Dependencies","text":"<p>Use <code>unittest.mock</code> for mocking:</p> <pre><code>from unittest.mock import AsyncMock, MagicMock, Mock, patch\n\n@pytest.mark.asyncio\nasync def test_http_request(self):\n    \"\"\"Test HTTP request with mocked aiohttp.\"\"\"\n    with patch(\"aiohttp.ClientSession\") as mock_session:\n        mock_session.return_value.__aenter__.return_value = AsyncMock()\n\n        # Your test code here\n</code></pre>"},{"location":"contributing/#7-testing-file-operations","title":"7. Testing File Operations","text":"<p>Use <code>temp_config_dir</code> fixture:</p> <pre><code>def test_config_persistence(self, temp_config_dir):\n    \"\"\"Test configuration is saved to file.\"\"\"\n    manager = MyManager(temp_config_dir)\n    manager.save_config({\"key\": \"value\"})\n\n    # Verify file exists\n    config_file = os.path.join(temp_config_dir, \"config.json\")\n    assert os.path.exists(config_file)\n</code></pre>"},{"location":"contributing/#8-testing-event-emission","title":"8. Testing Event Emission","text":"<pre><code>def test_event_emitted(self, device):\n    \"\"\"Test that event is emitted on state change.\"\"\"\n    events_received = []\n    device.events.on(DeviceEvents.UPDATE, lambda *args: events_received.append(args))\n\n    device.update_state(\"new_state\")\n\n    assert len(events_received) == 1\n    assert events_received[0][0] == device.identifier\n</code></pre>"},{"location":"contributing/#9-testing-abstract-base-classes","title":"9. Testing Abstract Base Classes","text":"<p>Create concrete implementations for testing:</p> <pre><code>class ConcreteTestClass(AbstractBaseClass):\n    \"\"\"Concrete implementation for testing.\"\"\"\n\n    def required_method(self):\n        return \"test_implementation\"\n\ndef test_abstract_class_functionality():\n    \"\"\"Test abstract class through concrete implementation.\"\"\"\n    obj = ConcreteTestClass()\n    assert obj.required_method() == \"test_implementation\"\n</code></pre>"},{"location":"contributing/#10-testing-error-conditions","title":"10. Testing Error Conditions","text":"<pre><code>def test_handles_missing_file(self, temp_config_dir):\n    \"\"\"Test graceful handling of missing config file.\"\"\"\n    manager = ConfigManager(temp_config_dir)\n\n    # Should not raise, should return empty/default\n    result = manager.load()\n\n    assert result == []\n\ndef test_raises_on_invalid_input(self):\n    \"\"\"Test that invalid input raises appropriate error.\"\"\"\n    obj = MyClass()\n\n    with pytest.raises(ValueError, match=\"Invalid input\"):\n        obj.process(None)\n</code></pre>"},{"location":"contributing/#running-your-new-tests","title":"Running Your New Tests","text":""},{"location":"contributing/#run-just-your-new-test","title":"Run just your new test","text":"<pre><code>pytest tests/test_config.py::TestNewFeature::test_basic_functionality -v\n</code></pre>"},{"location":"contributing/#run-the-whole-test-class","title":"Run the whole test class","text":"<pre><code>pytest tests/test_config.py::TestNewFeature -v\n</code></pre>"},{"location":"contributing/#run-with-coverage-to-see-what-youre-covering","title":"Run with coverage to see what you're covering","text":"<pre><code>pytest tests/test_config.py --cov=ucapi_framework.config --cov-report=term-missing -v\n</code></pre>"},{"location":"contributing/#checklist-before-committing","title":"Checklist Before Committing","text":"<ul> <li>[ ] Test name clearly describes what is being tested</li> <li>[ ] Test has a docstring explaining the test</li> <li>[ ] Test follows Arrange-Act-Assert pattern</li> <li>[ ] Test is independent (doesn't depend on other tests)</li> <li>[ ] Async tests use <code>@pytest.mark.asyncio</code></li> <li>[ ] External dependencies are mocked</li> <li>[ ] Both success and failure cases are tested</li> <li>[ ] Test runs successfully in isolation</li> <li>[ ] Test runs successfully with full test suite</li> <li>[ ] Code coverage is maintained or improved</li> </ul>"},{"location":"contributing/#common-patterns","title":"Common Patterns","text":""},{"location":"contributing/#testing-configuration-crud","title":"Testing Configuration CRUD","text":"<pre><code>def test_add_and_retrieve_device(self, config_manager):\n    \"\"\"Test adding and retrieving a device.\"\"\"\n    device = TestDevice(\"id1\", \"Device 1\", \"192.168.1.1\")\n\n    config_manager.add_or_update(device)\n    retrieved = config_manager.get(\"id1\")\n\n    assert retrieved is not None\n    assert retrieved.name == \"Device 1\"\n</code></pre>"},{"location":"contributing/#testing-device-lifecycle","title":"Testing Device Lifecycle","text":"<pre><code>@pytest.mark.asyncio\nasync def test_device_lifecycle(self, device):\n    \"\"\"Test complete device lifecycle.\"\"\"\n    assert device.connected is False\n\n    await device.connect()\n    assert device.connected is True\n\n    await device.disconnect()\n    assert device.connected is False\n</code></pre>"},{"location":"contributing/#testing-event-propagation","title":"Testing Event Propagation","text":"<pre><code>@pytest.mark.asyncio\nasync def test_device_event_propagates_to_entity(self, driver):\n    \"\"\"Test device events update entity state.\"\"\"\n    config = TestDeviceConfig(\"dev1\", \"Device 1\", \"192.168.1.1\")\n    driver.add_configured_device(config)\n\n    device = driver._configured_devices[\"dev1\"]\n    device._state = \"playing\"\n\n    await driver.on_device_connected(\"dev1\")\n\n    # Verify entity state was updated\n    driver.api.configured_entities.update_attributes.assert_called()\n</code></pre>"},{"location":"contributing/#questions","title":"Questions?","text":"<ul> <li>Check existing tests for similar patterns</li> <li>Review <code>tests/README.md</code> for more details</li> <li>Look at the test files for examples</li> </ul>"},{"location":"contributing/#code-coverage-goals","title":"Code Coverage Goals","text":"<ul> <li>Aim for &gt;=90% line coverage</li> <li>Focus on testing public APIs</li> <li>Don't test trivial getters/setters</li> <li>Do test error handling and edge cases</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide will walk you through creating your first Unfolded Circle Remote integration using the UCAPI Framework.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Install the framework using pip or uv:</p> uvpip <pre><code>uv add ucapi-framework\n</code></pre> <pre><code>pip install ucapi-framework\n</code></pre>"},{"location":"getting-started/#project-structure","title":"Project Structure","text":"<p>A typical integration has this structure:</p> <pre><code>my-integration/\n\u251c\u2500\u2500 intg-mydevice/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 driver.py          # Driver implementation\n\u2502   \u251c\u2500\u2500 device.py          # Device interface\n\u2502   \u251c\u2500\u2500 setup_flow.py      # Setup flow\n\u2502   \u2514\u2500\u2500 config.py          # Configuration dataclass\n\u251c\u2500\u2500 pyproject.toml\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"getting-started/#quick-example-rest-api-device","title":"Quick Example: REST API Device","text":"<p>Let's build a simple integration for a device with a REST API.</p>"},{"location":"getting-started/#1-define-your-configuration","title":"1. Define Your Configuration","text":"<pre><code># config.py\nfrom dataclasses import dataclass\n\n@dataclass\nclass MyDeviceConfig:\n    \"\"\"Device configuration.\"\"\"\n    identifier: str\n    name: str\n    host: str\n    api_key: str = \"\"\n</code></pre>"},{"location":"getting-started/#2-implement-your-device","title":"2. Implement Your Device","text":"<pre><code># device.py\nfrom ucapi_framework import StatelessHTTPDevice\nimport aiohttp\n\nclass MyDevice(StatelessHTTPDevice):\n    \"\"\"Device implementation.\"\"\"\n\n    @property\n    def identifier(self) -&gt; str:\n        return self._device_config.identifier\n\n    @property\n    def name(self) -&gt; str:\n        return self._device_config.name\n\n    @property\n    def address(self) -&gt; str:\n        return self._device_config.host\n\n    @property\n    def log_id(self) -&gt; str:\n        return f\"MyDevice[{self.identifier}]\"\n\n    async def verify_connection(self) -&gt; None:\n        \"\"\"Verify device is reachable.\"\"\"\n        url = f\"http://{self.address}/api/status\"\n        headers = {\"Authorization\": f\"Bearer {self._device_config.api_key}\"}\n\n        async with aiohttp.ClientSession() as session:\n            async with session.get(url, headers=headers) as response:\n                response.raise_for_status()\n\n    async def send_command(self, command: str) -&gt; None:\n        \"\"\"Send a command to the device.\"\"\"\n        url = f\"http://{self.address}/api/command\"\n        headers = {\"Authorization\": f\"Bearer {self._device_config.api_key}\"}\n        data = {\"command\": command}\n\n        async with aiohttp.ClientSession() as session:\n            async with session.post(url, json=data, headers=headers) as response:\n                response.raise_for_status()\n</code></pre>"},{"location":"getting-started/#3-create-your-driver","title":"3. Create Your Driver","text":"<pre><code># driver.py\nfrom ucapi_framework import BaseIntegrationDriver\nfrom ucapi import EntityTypes, media_player\nfrom .device import MyDevice\nfrom .config import MyDeviceConfig\n\nclass MyIntegrationDriver(BaseIntegrationDriver[MyDevice, MyDeviceConfig]):\n    \"\"\"Integration driver.\"\"\"\n</code></pre>"},{"location":"getting-started/#4-implement-setup-flow","title":"4. Implement Setup Flow","text":"<pre><code># setup_flow.py\nfrom ucapi_framework import BaseSetupFlow\nfrom ucapi.api_definitions import RequestUserInput\nfrom .config import MyDeviceConfig\n\nclass MySetupFlow(BaseSetupFlow[MyDeviceConfig]):\n    \"\"\"Setup flow for manual device entry.\"\"\"\n\n    def get_manual_entry_form(self) -&gt; RequestUserInput:\n        \"\"\"Return the manual entry form.\"\"\"\n        return RequestUserInput(\n            title=\"Add Device\",\n            settings=[\n                {\n                    \"id\": \"host\",\n                    \"label\": {\"en\": \"Device IP Address\", \"de\": \"Ger\u00e4te-IP-Adresse\"},\n                    \"field\": {\"text\": {\"value\": \"\"}},\n                },\n                {\n                    \"id\": \"name\",\n                    \"label\": {\"en\": \"Device Name\", \"de\": \"Ger\u00e4tename\"},\n                    \"field\": {\"text\": {\"value\": \"\"}},\n                },\n                {\n                    \"id\": \"api_key\",\n                    \"label\": {\"en\": \"API Key\", \"de\": \"API-Schl\u00fcssel\"},\n                    \"field\": {\"text\": {\"value\": \"\"}},\n                },\n            ],\n        )\n\n    async def query_device(self, input_values: dict) -&gt; MyDeviceConfig:\n        \"\"\"Create device config from user input.\"\"\"\n        return MyDeviceConfig(\n            identifier=input_values.get(\"identifier\", input_values[\"host\"].replace(\".\", \"_\")),\n            name=input_values[\"name\"],\n            host=input_values[\"host\"],\n            api_key=input_values.get(\"api_key\", \"\"),\n        )\n</code></pre>"},{"location":"getting-started/#5-wire-it-all-up","title":"5. Wire It All Up","text":"<pre><code># __init__.py\nimport asyncio\nimport logging\nfrom ucapi import IntegrationAPI\n\nfrom .driver import MyIntegrationDriver\nfrom .setup_flow import MySetupFlow\nfrom .config import MyDeviceConfig\nfrom ucapi_framework import BaseConfigManager\n\n_LOG = logging.getLogger(__name__)\n\nasync def main():\n    \"\"\"Main entry point.\"\"\"\n    loop = asyncio.get_running_loop()\n\n    # Create configuration manager\n    config_manager = BaseConfigManager[MyDeviceConfig](\n        data_path=\"./config\",\n    )\n\n    # Create driver\n    driver = MyIntegrationDriver()\n    driver.config_manager = config_manager\n\n    # Wire up config callbacks\n    config_manager._add_handler = driver.on_device_added\n    config_manager._remove_handler = driver.on_device_removed\n\n    # Create setup flow\n    setup_flow = MySetupFlow(config_manager, discovery=None)\n\n    # Register with API\n    api = driver.api\n    api.register_setup_handler(setup_flow.create_handler())\n\n    # Start integration\n    await api.init(\"mydevice.json\", MySetupFlow)\n\n    _LOG.info(\"Integration started\")\n\nif __name__ == \"__main__\":\n    logging.basicConfig(level=logging.DEBUG)\n    asyncio.run(main())\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you have a basic integration:</p> <ol> <li>Add Discovery - Implement device discovery if your devices support it</li> <li>Add Entities - Create entity classes for your device capabilities</li> <li>Handle Events - Override event handlers for custom behavior</li> <li>Add Polling - Use <code>PollingDevice</code> if your device needs state polling</li> <li>Add WebSocket - Use <code>WebSocketDevice</code> for real-time updates</li> </ol> <p>Check out the User Guide for detailed information on each component!</p>"},{"location":"migration-guide/","title":"Migration Guide: Converting to ucapi framework","text":"<p>This guide helps you migrate an existing Unfolded Circle integration to use the ucapi framework. We'll show you the before/after for each component with real examples from the PSN integration migration.</p>"},{"location":"migration-guide/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Why Migrate?</li> <li>Migration Overview</li> <li>Step-by-Step Migration</li> <li>1. Configuration Management</li> <li>2. Device Implementation</li> <li>3. Setup Flow</li> <li>4. Driver Integration</li> <li>5. Entity Implementation</li> <li>Common Patterns</li> <li>Testing Your Migration</li> </ul>"},{"location":"migration-guide/#why-migrate","title":"Why Migrate?","text":"<p>Before ucapi_framework_: - ~1500 lines of boilerplate per integration - Manual configuration management with dict manipulation - Global state management with module-level variables - Repetitive event handler wiring - Copy-paste setup flow code - Manual device lifecycle management</p> <p>After ucapi_framework_: - ~400 lines of integration-specific code - Type-safe configuration with dataclasses - Clean OOP design with proper encapsulation - Automatic event handler wiring - Reusable setup flow base class - Automatic device lifecycle management - Full IDE autocomplete support</p> <p>Code Reduction: ~70% less code to write and maintain!</p>"},{"location":"migration-guide/#migration-overview","title":"Migration Overview","text":"<p>The migration follows these steps:</p> <ol> <li>Configuration - Replace dict-based config with typed dataclass + BaseConfigManager</li> <li>Device - Inherit from device interface (StatelessHTTPDevice, PollingDevice, etc.)</li> <li>Setup Flow - Inherit from BaseSetupFlow, implement required methods</li> <li>Driver - Inherit from BaseIntegrationDriver, remove global state</li> <li>Entities - Update to reference device instances instead of global state</li> </ol>"},{"location":"migration-guide/#step-by-step-migration","title":"Step-by-Step Migration","text":""},{"location":"migration-guide/#1-configuration-management","title":"1. Configuration Management","text":""},{"location":"migration-guide/#before-dict-based-configuration","title":"Before: Dict-Based Configuration","text":"<pre><code># config.py - Old approach\nimport json\nimport os\nfrom typing import TypedDict\n\nclass PSNDevice(TypedDict):\n    \"\"\"PSN device configuration.\"\"\"\n    identifier: str\n    name: str\n    npsso: str\n\n# Global configuration dict\ndevices: dict[str, PSNDevice] = {}\n_config_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"config.json\")\n\ndef _load() -&gt; bool:\n    \"\"\"Load configuration from disk.\"\"\"\n    global devices\n    if not os.path.exists(_config_path):\n        return True\n\n    try:\n        with open(_config_path, \"r\", encoding=\"utf-8\") as f:\n            data = json.load(f)\n            devices = {k: PSNDevice(**v) for k, v in data.items()}\n        return True\n    except Exception as e:\n        return False\n\ndef _store() -&gt; bool:\n    \"\"\"Store configuration to disk.\"\"\"\n    try:\n        with open(_config_path, \"w\", encoding=\"utf-8\") as f:\n            json.dump({k: dict(v) for k, v in devices.items()}, f, indent=4)\n        return True\n    except Exception as e:\n        return False\n\ndef add_device(device: PSNDevice) -&gt; bool:\n    \"\"\"Add or update device.\"\"\"\n    devices[device[\"identifier\"]] = device\n    return _store()\n\ndef remove_device(identifier: str) -&gt; bool:\n    \"\"\"Remove device.\"\"\"\n    if identifier in devices:\n        devices.pop(identifier)\n        return _store()\n    return False\n\ndef get_device(identifier: str) -&gt; PSNDevice | None:\n    \"\"\"Get device by identifier.\"\"\"\n    return devices.get(identifier)\n\ndef all_devices() -&gt; list[PSNDevice]:\n    \"\"\"Get all configured devices.\"\"\"\n    return list(devices.values())\n\ndef clear() -&gt; bool:\n    \"\"\"Clear all devices.\"\"\"\n    global devices\n    devices = {}\n    return _store()\n\n# Initialize on import\n_load()\n</code></pre> <p>Problems: - ~80 lines of boilerplate - Global mutable state - Manual JSON serialization - No type safety for operations - Manual error handling everywhere - Dict manipulation prone to errors</p>"},{"location":"migration-guide/#after-baseconfigmanager-with-dataclass","title":"After: BaseConfigManager with Dataclass","text":"<pre><code># config.py - New approach\nfrom dataclasses import dataclass\nfrom ucapi_framework import BaseConfigManager\n\n@dataclass\nclass PSNDevice:\n    \"\"\"PSN device configuration.\"\"\"\n    identifier: str\n    name: str\n    npsso: str\n\nclass PSNConfigManager(BaseConfigManager[PSNDevice]):\n    \"\"\"PSN device configuration manager with JSON persistence.\"\"\"\n    pass\n</code></pre> <p>Benefits: - ~15 lines total (80% reduction!) - No global state - Type-safe operations - Automatic JSON serialization - Built-in error handling - IDE autocomplete for all operations</p> <p>Usage Comparison:</p> <pre><code># Old:\nimport config\ndevice = config.get_device(device_id)\nconfig.add_device(new_device)\nall_devices = config.all_devices()\n\n# New:\nconfig = PSNDeviceManager(\"config.json\", PSNDevice)\ndevice = config.get(device_id)\nconfig.add_or_update(new_device)\nall_devices = config.all()\n</code></pre>"},{"location":"migration-guide/#2-device-implementation","title":"2. Device Implementation","text":""},{"location":"migration-guide/#before-manual-connection-management","title":"Before: Manual Connection Management","text":"<pre><code># psn.py - Old approach\nclass PSNAccount:\n    \"\"\"PlayStation Network account.\"\"\"\n\n    def __init__(self, identifier: str, name: str, npsso: str):\n        self.identifier = identifier\n        self.name = name\n        self._npsso = npsso\n        self.state = \"OFF\"\n        self._ws = None\n        self._ws_task = None\n        self.events = EventEmitter()\n\n    async def connect(self) -&gt; bool:\n        \"\"\"Connect to PSN WebSocket.\"\"\"\n        try:\n            # Manual WebSocket setup\n            self._ws = await websockets.connect(\n                \"wss://psn-api.example.com/ws\",\n                extra_headers={\"Authorization\": f\"Bearer {self._npsso}\"}\n            )\n\n            # Manual task management\n            self._ws_task = asyncio.create_task(self._receive_loop())\n\n            self.events.emit(\"connected\", self.identifier)\n            return True\n\n        except Exception as e:\n            self.events.emit(\"connection_error\", self.identifier, str(e))\n            return False\n\n    async def _receive_loop(self):\n        \"\"\"Manually manage WebSocket receive loop.\"\"\"\n        try:\n            while self._ws:\n                message = await self._ws.recv()\n                data = json.loads(message)\n                await self._process_message(data)\n        except Exception as e:\n            self.events.emit(\"connection_error\", self.identifier, str(e))\n        finally:\n            await self.disconnect()\n\n    async def disconnect(self) -&gt; None:\n        \"\"\"Disconnect from WebSocket.\"\"\"\n        if self._ws_task:\n            self._ws_task.cancel()\n            try:\n                await self._ws_task\n            except asyncio.CancelledError:\n                pass\n            self._ws_task = None\n\n        if self._ws:\n            await self._ws.close()\n            self._ws = None\n\n        self.events.emit(\"disconnected\", self.identifier)\n\n    async def _process_message(self, data: dict) -&gt; None:\n        \"\"\"Process received message.\"\"\"\n        self.state = data.get(\"state\", \"UNKNOWN\")\n        self.events.emit(\"state_changed\", self.identifier, self.state)\n</code></pre> <p>Problems: - ~100+ lines of connection boilerplate - Manual WebSocket lifecycle management - Manual task management and cancellation - Error handling repeated everywhere - Reconnection logic missing - Testing difficult due to tight coupling</p>"},{"location":"migration-guide/#after-inherit-websocketdevice","title":"After: Inherit WebSocketDevice","text":"<pre><code># psn.py - New approach\nfrom ucapi_framework_ import WebSocketDevice\nimport websockets\nimport json\n\nclass PSNAccount(WebSocketDevice):\n    \"\"\"PlayStation Network account using WebSocketDevice base.\"\"\"\n\n    def __init__(self, device_config):\n        super().__init__(\n            identifier=device_config.identifier,\n            name=device_config.name\n        )\n        self._npsso = device_config.npsso\n        self.state = \"OFF\"\n\n    async def create_websocket(self):\n        \"\"\"Create WebSocket connection - called by base class.\"\"\"\n        return await websockets.connect(\n            \"wss://psn-api.example.com/ws\",\n            extra_headers={\"Authorization\": f\"Bearer {self._npsso}\"}\n        )\n\n    async def handle_message(self, message: str) -&gt; None:\n        \"\"\"Handle received WebSocket message - called by base class.\"\"\"\n        data = json.loads(message)\n        self.state = data.get(\"state\", \"UNKNOWN\")\n        self.events.emit(\"state_changed\", self.identifier, self.state)\n</code></pre> <p>Benefits: - ~30 lines (70% reduction!) - Automatic WebSocket lifecycle management - Automatic reconnection logic - Automatic task management - Built-in error handling and logging - Easy to test with mocked WebSocket - Focus on business logic only</p> <p>Other Device Patterns:</p> <pre><code># For HTTP REST API devices:\nclass MyDevice(StatelessHTTPDevice):\n    async def verify_connection(self) -&gt; bool:\n        \"\"\"Test connection.\"\"\"\n        return await self._make_request(\"/status\")\n\n    async def handle_data_from_device(self, data: dict) -&gt; None:\n        \"\"\"Process response.\"\"\"\n        pass\n\n# For polling devices:\nclass MyDevice(PollingDevice):\n    def __init__(self, config):\n        super().__init__(\n            identifier=config.device_id,\n            name=config.name,\n            poll_interval=5.0  # Poll every 5 seconds\n        )\n\n    async def poll_device(self) -&gt; None:\n        \"\"\"Fetch and process state.\"\"\"\n        state = await self._fetch_state()\n        self.events.emit(\"state_changed\", self.identifier, state)\n</code></pre>"},{"location":"migration-guide/#3-setup-flow","title":"3. Setup Flow","text":""},{"location":"migration-guide/#before-manual-setup-flow-implementation","title":"Before: Manual Setup Flow Implementation","text":"<pre><code># setup_flow.py - Old approach (~200 lines)\nimport config\nfrom ucapi import SetupDriver, SetupError, SetupComplete\n\nclass PSNSetupFlow:\n    \"\"\"Manual setup flow implementation.\"\"\"\n\n    def __init__(self):\n        self._setup_step = \"START\"\n        self._pending_device = None\n\n    async def handle_setup_request(self, msg):\n        \"\"\"Handle initial setup request.\"\"\"\n        if msg.reconfigure:\n            return await self._show_configuration_mode()\n        else:\n            config.clear()\n            return await self._show_manual_entry()\n\n    async def handle_user_data_response(self, msg):\n        \"\"\"Route user responses to appropriate handlers.\"\"\"\n        if self._setup_step == \"CONFIGURATION_MODE\":\n            return await self._handle_configuration_action(msg)\n        elif self._setup_step == \"MANUAL_ENTRY\":\n            return await self._handle_manual_entry_response(msg)\n        # ... more manual routing\n\n    async def _show_configuration_mode(self):\n        \"\"\"Show configuration mode screen.\"\"\"\n        self._setup_step = \"CONFIGURATION_MODE\"\n        devices = config.all_devices()\n\n        choices = [{\"id\": d[\"identifier\"], \"label\": d[\"name\"]} for d in devices]\n\n        return RequestUserInput(\n            title=\"PSN Configuration\",\n            settings=[\n                {\n                    \"id\": \"choice\",\n                    \"label\": \"Configured Devices\",\n                    \"field\": {\"dropdown\": {\"items\": choices}}\n                },\n                {\n                    \"id\": \"action\",\n                    \"label\": \"Action\",\n                    \"field\": {\"dropdown\": {\"items\": [\n                        {\"id\": \"add\", \"label\": \"Add Device\"},\n                        {\"id\": \"remove\", \"label\": \"Remove Device\"},\n                    ]}}\n                }\n            ]\n        )\n\n    async def _handle_configuration_action(self, msg):\n        \"\"\"Handle configuration mode actions.\"\"\"\n        action = msg.input_values.get(\"action\")\n        choice = msg.input_values.get(\"choice\")\n\n        if action == \"add\":\n            return await self._show_manual_entry()\n        elif action == \"remove\":\n            if config.remove_device(choice):\n                return SetupComplete()\n            return SetupError()\n        # ... more manual action handling\n\n    async def _show_manual_entry(self):\n        \"\"\"Show manual entry form.\"\"\"\n        self._setup_step = \"MANUAL_ENTRY\"\n        return RequestUserInput(\n            title=\"Add PSN Account\",\n            settings=[\n                {\"id\": \"name\", \"label\": \"Name\", \"field\": {\"text\": {\"value\": \"\"}}},\n                {\"id\": \"npsso\", \"label\": \"NPSSO Token\", \"field\": {\"text\": {\"value\": \"\"}}},\n            ]\n        )\n\n    async def _handle_manual_entry_response(self, msg):\n        \"\"\"Handle manual entry response.\"\"\"\n        name = msg.input_values[\"name\"]\n        npsso = msg.input_values[\"npsso\"]\n\n        # Create device config\n        device_config = {\n            \"identifier\": npsso[:8],  # Use part of token as ID\n            \"name\": name,\n            \"npsso\": npsso,\n        }\n\n        # Check for duplicates\n        if config.get_device(device_config[\"identifier\"]):\n            return SetupError(error_type=IntegrationSetupError.DEVICE_EXISTS)\n\n        # Save configuration\n        if not config.add_device(device_config):\n            return SetupError()\n\n        return SetupComplete()\n\n    # ... more methods for backup/restore, etc.\n</code></pre> <p>Problems: - ~200+ lines of repetitive code - Manual state management (<code>_setup_step</code>) - Manual routing logic - Duplicate device checking repeated - Manual configuration screen building - No reusability across integrations</p>"},{"location":"migration-guide/#after-inherit-basesetupflow","title":"After: Inherit BaseSetupFlow","text":"<pre><code># setup_flow.py - New approach\nfrom ucapi_framework_ import BaseSetupFlow\nfrom ucapi import IntegrationSetupError\nimport config\n\nclass PSNSetupFlow(BaseSetupFlow[config.PSNDevice]):\n    \"\"\"PSN setup flow using BaseSetupFlow.\"\"\"\n\n    async def discover_devices(self) -&gt; list:\n        \"\"\"PSN doesn't support auto-discovery.\"\"\"\n        return []\n\n    def get_manual_entry_fields(self) -&gt; list[dict]:\n        \"\"\"Define manual entry fields.\"\"\"\n        return [\n            {\n                \"id\": \"name\",\n                \"label\": {\"en\": \"Account Name\"},\n                \"field\": {\"text\": {\"value\": \"\"}},\n            },\n            {\n                \"id\": \"npsso\",\n                \"label\": {\"en\": \"NPSSO Token\"},\n                \"field\": {\"text\": {\"value\": \"\"}},\n            },\n        ]\n\n    def create_device_from_manual_entry(\n        self, input_values: dict[str, str]\n    ) -&gt; config.PSNDevice:\n        \"\"\"Create device config from manual entry.\"\"\"\n        name = input_values[\"name\"]\n        npsso = input_values[\"npsso\"]\n\n        return config.PSNDevice(\n            identifier=npsso[:8],  # Use part of token as ID\n            name=name,\n            npsso=npsso,\n        )\n\n    def create_device_from_discovery(\n        self, device_id: str, discovery_data: dict\n    ) -&gt; config.PSNDevice:\n        \"\"\"Not used - PSN doesn't support discovery.\"\"\"\n        raise NotImplementedError()\n\n    def get_device_name(self, device_config: config.PSNDevice) -&gt; str:\n        \"\"\"Extract device name.\"\"\"\n        return device_config.name\n</code></pre> <p>Benefits: - ~50 lines (75% reduction!) - No manual state management - No manual routing - Automatic duplicate checking - Automatic configuration mode - Built-in backup/restore - Fully reusable pattern</p> <p>Features You Get For Free: - Configuration mode (add/update/remove/reset devices) - Duplicate device detection - Backup creation and restore - Multi-screen setup flows - Error handling and validation - State management</p>"},{"location":"migration-guide/#4-driver-integration","title":"4. Driver Integration","text":""},{"location":"migration-guide/#before-global-state-and-manual-event-handlers","title":"Before: Global State and Manual Event Handlers","text":"<pre><code># driver.py - Old approach (~300 lines)\nimport asyncio\nimport ucapi\nimport ucapi.api as uc\nfrom psn import PSNAccount\nimport config\n\n_LOG = logging.getLogger(\"driver\")\n_LOOP = asyncio.get_event_loop()\n\n# Global API and device storage\napi = uc.IntegrationAPI(_LOOP)\n_configured_accounts: dict[str, PSNAccount] = {}\n\n@api.listens_to(ucapi.Events.CONNECT)\nasync def on_r2_connect_cmd() -&gt; None:\n    \"\"\"Manually connect all devices.\"\"\"\n    _LOG.debug(\"Connect command\")\n    await api.set_device_state(ucapi.DeviceStates.CONNECTED)\n    for account in _configured_accounts.values():\n        await account.connect()\n\n@api.listens_to(ucapi.Events.DISCONNECT)\nasync def on_r2_disconnect_cmd():\n    \"\"\"Manually disconnect all devices.\"\"\"\n    _LOG.debug(\"Disconnect command\")\n    for account in _configured_accounts.values():\n        await account.disconnect()\n\n@api.listens_to(ucapi.Events.ENTER_STANDBY)\nasync def on_r2_enter_standby() -&gt; None:\n    \"\"\"Manually handle standby.\"\"\"\n    _LOG.debug(\"Enter standby\")\n    for account in _configured_accounts.values():\n        await account.disconnect()\n\n@api.listens_to(ucapi.Events.SUBSCRIBE_ENTITIES)\nasync def on_subscribe_entities(entity_ids: list[str]) -&gt; None:\n    \"\"\"Manually subscribe to entities.\"\"\"\n    _LOG.debug(\"Subscribe: %s\", entity_ids)\n    for entity_id in entity_ids:\n        account_id = entity_id  # entity_id IS account_id for PSN\n\n        # Check if already configured\n        if account_id in _configured_accounts:\n            account = _configured_accounts[account_id]\n            state = _map_psn_state(account.state)\n            api.configured_entities.update_attributes(\n                entity_id, {media_player.Attributes.STATE: state}\n            )\n            continue\n\n        # Load from config\n        device_config = config.get_device(account_id)\n        if device_config:\n            _add_configured_account(device_config)\n\ndef _add_configured_account(device_config: dict) -&gt; None:\n    \"\"\"Manually create and wire up account.\"\"\"\n    account = PSNAccount(\n        identifier=device_config[\"identifier\"],\n        name=device_config[\"name\"],\n        npsso=device_config[\"npsso\"],\n    )\n\n    # Manual event handler setup\n    account.events.on(\"connected\", _on_account_connected)\n    account.events.on(\"disconnected\", _on_account_disconnected)\n    account.events.on(\"connection_error\", _on_account_error)\n    account.events.on(\"state_changed\", _on_state_changed)\n\n    _configured_accounts[account.identifier] = account\n\n    # Manual entity creation\n    entity = _create_media_player_entity(account)\n    api.available_entities.add(entity)\n\ndef _on_state_changed(account_id: str, state: str) -&gt; None:\n    \"\"\"Manually update entity state.\"\"\"\n    mapped_state = _map_psn_state(state)\n    api.configured_entities.update_attributes(\n        account_id, {media_player.Attributes.STATE: mapped_state}\n    )\n\ndef _map_psn_state(psn_state: str) -&gt; media_player.States:\n    \"\"\"Manually map states.\"\"\"\n    match psn_state:\n        case \"PLAYING\":\n            return media_player.States.PLAYING\n        case \"ON\" | \"MENU\":\n            return media_player.States.ON\n        case \"OFF\":\n            return media_player.States.OFF\n        case _:\n            return media_player.States.UNKNOWN\n\n# ... more manual setup\n</code></pre> <p>Problems: - ~300 lines of boilerplate - Global mutable state (<code>_configured_accounts</code>) - Manual event handler registration - Manual entity creation and registration - Manual state synchronization - Manual lifecycle management - Difficult to test</p>"},{"location":"migration-guide/#after-inherit-baseintegrationdriver","title":"After: Inherit BaseIntegrationDriver","text":"<pre><code># driver.py - New approach\nimport asyncio\nimport logging\nfrom typing import Any\nfrom ucapi import media_player\nfrom ucapi_framework_ import BaseIntegrationDriver\nimport config\nfrom config import PSNDevice\nfrom psn import PSNAccount\nfrom media_player import PSNMediaPlayer\nfrom setup_flow import PSNSetupFlow\n\n_LOG = logging.getLogger(\"driver\")\n_LOOP = asyncio.get_event_loop()\n\nclass PSNIntegrationDriver(BaseIntegrationDriver[PSNAccount, PSNDevice]):\n    \"\"\"PSN Integration driver.\"\"\"\n\n    def __init__(self):\n        super().__init__(\n            device_class=PSNAccount,\n            entity_classes=[PSNMediaPlayer]\n        )\n\n    # ========================================================================\n    # Required Methods - Integration-Specific Logic\n    # ========================================================================\n\n    def device_from_entity_id(self, entity_id: str) -&gt; str | None:\n        \"\"\"Extract device ID from entity ID.\"\"\"\n        return entity_id  # For PSN, entity_id IS the device_id\n\n    def get_entity_ids_for_device(self, device_id: str) -&gt; list[str]:\n        \"\"\"Get entity IDs for a device.\"\"\"\n        return [device_id]  # One media_player per account\n\n    def map_device_state(self, device_state: Any) -&gt; media_player.States:\n        \"\"\"Map PSN state to media player state.\"\"\"\n        match device_state:\n            case \"PLAYING\":\n                return media_player.States.PLAYING\n            case \"ON\" | \"MENU\":\n                return media_player.States.ON\n            case \"OFF\":\n                return media_player.States.OFF\n            case _:\n                return media_player.States.UNKNOWN\n\n    def create_entities(\n        self, device_config: PSNDevice, device: PSNAccount\n    ) -&gt; list[PSNMediaPlayer]:\n        \"\"\"Create entity instances for a device.\"\"\"\n        return [PSNMediaPlayer(device_config, device)]\n\n# Create driver instance\ndriver = PSNIntegrationDriver(_LOOP)\ndriver.register_setup_handler(PSNSetupFlow, config.PSNDeviceManager)\n</code></pre> <p>Benefits: - ~90 lines (70% reduction!) - No global state - Automatic event handler registration - Automatic entity lifecycle - Automatic state synchronization - Clean, testable design - Focus on integration-specific logic only</p> <p>What You Get For Free: - Device lifecycle management - Event handler wiring - Entity registration - State synchronization - Remote Two event handling - Configuration loading - Error handling and logging</p>"},{"location":"migration-guide/#5-entity-implementation","title":"5. Entity Implementation","text":""},{"location":"migration-guide/#before-global-references","title":"Before: Global References","text":"<pre><code># media_player.py - Old approach\nimport ucapi\nfrom ucapi import MediaPlayer\n\nasync def create_media_player_entity(account_id: str, name: str) -&gt; MediaPlayer:\n    \"\"\"Create media player entity - referenced global state.\"\"\"\n    entity = MediaPlayer(\n        identifier=account_id,\n        name=ucapi.EntityName(name, \"en\"),\n        features=[],\n        attributes={},\n        device_class=ucapi.media_player.DeviceClasses.TV,\n    )\n    return entity\n\n# Command handler referenced global _configured_accounts dict\nasync def media_player_cmd_handler(entity, cmd_id, params):\n    \"\"\"Handler that needs global state.\"\"\"\n    import driver  # Circular import!\n    account = driver._configured_accounts.get(entity.id)\n    if not account:\n        return ucapi.StatusCodes.NOT_FOUND\n    # Handle command...\n</code></pre> <p>Problems: - Circular dependencies - Global state references - No type safety - Difficult to test - Tight coupling</p>"},{"location":"migration-guide/#after-instance-references","title":"After: Instance References","text":"<pre><code># media_player.py - New approach\nimport logging\nfrom typing import Any\nfrom ucapi import EntityName, MediaPlayer, StatusCodes, media_player\nfrom config import PSNDevice\nfrom psn import PSNAccount\n\n_LOG = logging.getLogger(__name__)\n\nclass PSNMediaPlayer(MediaPlayer):\n    \"\"\"PSN Media Player entity with device reference.\"\"\"\n\n    def __init__(self, device_config: PSNDevice, device: PSNAccount):\n        \"\"\"Initialize with device instance - no global state.\"\"\"\n        self._device = device\n\n        super().__init__(\n            identifier=device_config.identifier,\n            name=EntityName(device_config.name, \"en\"),\n            features=[\n                media_player.Features.ON_OFF,\n                media_player.Features.TOGGLE,\n            ],\n            attributes={\n                media_player.Attributes.STATE: media_player.States.UNKNOWN,\n            },\n            device_class=media_player.DeviceClasses.STREAMING_BOX,\n            cmd_handler=self.handle_command,\n        )\n\n    async def handle_command(\n        self, entity: MediaPlayer, cmd_id: str, params: dict[str, Any] | None\n    ) -&gt; StatusCodes:\n        \"\"\"Handle media player commands - uses self._device.\"\"\"\n        _LOG.info(\"Command: %s %s\", cmd_id, params)\n\n        # Direct device reference - no global lookup!\n        if cmd_id == media_player.Commands.ON:\n            await self._device.turn_on()\n            return StatusCodes.OK\n\n        if cmd_id == media_player.Commands.OFF:\n            await self._device.turn_off()\n            return StatusCodes.OK\n\n        return StatusCodes.NOT_IMPLEMENTED\n</code></pre> <p>Benefits: - No circular dependencies - No global state - Type-safe device reference - Easy to test - Clean separation of concerns</p>"},{"location":"migration-guide/#common-patterns","title":"Common Patterns","text":""},{"location":"migration-guide/#pattern-multi-device-integration","title":"Pattern: Multi-Device Integration","text":"<p>If your integration manages multiple device types:</p> <pre><code>class MyDriver(BaseIntegrationDriver[MyDevice, MyDeviceConfig]):\n    def get_entity_ids_for_device(self, device_id: str) -&gt; list[str]:\n        \"\"\"Multiple entities per device.\"\"\"\n        return [\n            f\"{device_id}_player\",\n            f\"{device_id}_light\",\n            f\"{device_id}_sensor\",\n        ]\n\n    def create_entities(self, device_config, device):\n        \"\"\"Create multiple entity types.\"\"\"\n        return [\n            MyMediaPlayerEntity(device_config, device),\n            MyLightEntity(device_config, device),\n            MySensorEntity(device_config, device),\n        ]\n</code></pre>"},{"location":"migration-guide/#pattern-api-authentication","title":"Pattern: API Authentication","text":"<p>Use pre-discovery screens to collect credentials:</p> <pre><code>class MySetupFlow(BaseSetupFlow[MyDeviceConfig]):\n    async def get_pre_discovery_screen(self):\n        \"\"\"Collect API credentials before discovery.\"\"\"\n        return RequestUserInput(\n            title=\"API Configuration\",\n            settings=[\n                {\"id\": \"api_key\", \"label\": \"API Key\", \"field\": {\"text\": {...}}},\n            ]\n        )\n\n    async def discover_devices(self):\n        \"\"\"Use credentials from self._pre_discovery_data.\"\"\"\n        api_key = self._pre_discovery_data.get(\"api_key\")\n        # Perform authenticated discovery...\n</code></pre>"},{"location":"migration-guide/#pattern-complex-setup","title":"Pattern: Complex Setup","text":"<p>Use post-selection screens for additional configuration:</p> <pre><code>async def get_additional_configuration_screen(self, device_config, previous_input):\n    \"\"\"Show zone selection after device chosen.\"\"\"\n    return RequestUserInput(\n        title=\"Zone Configuration\",\n        settings=[\n            {\"id\": \"zone\", \"label\": \"Zone\", \"field\": {\"dropdown\": {...}}},\n        ]\n    )\n\nasync def handle_additional_configuration_response(self, msg):\n    \"\"\"Update device config with zone.\"\"\"\n    self._pending_device_config.zone = msg.input_values[\"zone\"]\n    return None  # Complete setup\n</code></pre>"},{"location":"migration-guide/#testing-your-migration","title":"Testing Your Migration","text":""},{"location":"migration-guide/#unit-testing","title":"Unit Testing","text":"<p>The new architecture is much easier to test:</p> <pre><code>import pytest\nfrom myintegration.driver import MyDriver\nfrom myintegration.config import MyDeviceConfig\n\n@pytest.fixture\ndef driver():\n    loop = asyncio.get_event_loop()\n    return MyDriver(loop)\n\n@pytest.fixture\ndef device_config():\n    return MyDeviceConfig(\n        device_id=\"test123\",\n        name=\"Test Device\",\n        host=\"192.168.1.100\",\n    )\n\nasync def test_device_creation(driver, device_config):\n    \"\"\"Test device lifecycle without global state.\"\"\"\n    device = driver._device_class(device_config)\n    assert device.identifier == \"test123\"\n    assert device.name == \"Test Device\"\n\nasync def test_state_mapping(driver):\n    \"\"\"Test state mapping.\"\"\"\n    assert driver.map_device_state(\"PLAYING\") == media_player.States.PLAYING\n    assert driver.map_device_state(\"OFF\") == media_player.States.OFF\n</code></pre>"},{"location":"migration-guide/#integration-testing","title":"Integration Testing","text":"<p>Test with real Remote Two connection:</p> <ol> <li>Run your integration</li> <li>Add device through Remote Two UI</li> <li>Verify device appears in <code>config.json</code></li> <li>Verify entity shows up in Remote Two</li> <li>Test commands through Remote Two UI</li> </ol>"},{"location":"migration-guide/#migration-checklist","title":"Migration Checklist","text":"<ul> <li>[ ] Configuration converted to dataclass + BaseConfigManager</li> <li>[ ] Device inherits from appropriate base class (StatelessHTTPDevice, PollingDevice, etc.)</li> <li>[ ] Setup flow inherits from BaseSetupFlow</li> <li>[ ] Driver inherits from BaseIntegrationDriver</li> <li>[ ] All global state removed</li> <li>[ ] Entities reference device instances, not globals</li> <li>[ ] Abstract method names updated (no underscores)</li> <li>[ ] Manual event handler registration removed</li> <li>[ ] Manual entity lifecycle code removed</li> <li>[ ] Unit tests updated</li> <li>[ ] Integration tests pass</li> <li>[ ] Documentation updated</li> </ul>"},{"location":"migration-guide/#need-help","title":"Need Help?","text":"<ul> <li>Check the PSN integration in this repo for a complete example</li> <li>Review inline docstrings in ucapi_framework_ modules</li> <li>See README.md for detailed API documentation</li> <li>Open an issue on GitHub for questions</li> </ul>"},{"location":"api/config/","title":"Configuration API Reference","text":"<p>Configuration management handles device configuration storage and persistence.</p>"},{"location":"api/config/#baseconfigmanager","title":"BaseConfigManager","text":""},{"location":"api/config/#ucapi_framework.config.BaseConfigManager","title":"ucapi_framework.config.BaseConfigManager","text":"<pre><code>BaseConfigManager(\n    data_path: str,\n    add_handler: Callable[[DeviceT], None] | None = None,\n    remove_handler: Callable[[DeviceT | None], None]\n    | None = None,\n    config_class: type[DeviceT] | None = None,\n)\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[DeviceT]</code></p> <p>Base class for device configuration management.</p> <p>Handles: - Loading/storing configuration from/to JSON - CRUD operations (add, update, remove, get) - Configuration callbacks - Optional backup/restore support</p> <p>          Class Type Parameters:        </p> Name Bound or Constraints Description Default <code>DeviceT</code> <p>The device configuration dataclass type</p> required <p>Create a configuration instance.</p> <p>:param data_path: Configuration path for the configuration file :param add_handler: Optional callback when device is added :param remove_handler: Optional callback when device is removed :param config_class: The configuration dataclass type (optional, auto-detected from type hints if not provided)</p>"},{"location":"api/config/#ucapi_framework.config.BaseConfigManager-attributes","title":"Attributes","text":""},{"location":"api/config/#ucapi_framework.config.BaseConfigManager.data_path","title":"data_path  <code>property</code>","text":"<pre><code>data_path: str\n</code></pre> <p>Return the configuration path.</p>"},{"location":"api/config/#ucapi_framework.config.BaseConfigManager-functions","title":"Functions","text":""},{"location":"api/config/#ucapi_framework.config.BaseConfigManager.all","title":"all","text":"<pre><code>all() -&gt; Iterator[DeviceT]\n</code></pre> <p>Get an iterator for all device configurations.</p>"},{"location":"api/config/#ucapi_framework.config.BaseConfigManager.contains","title":"contains","text":"<pre><code>contains(device_id: str) -&gt; bool\n</code></pre> <p>Check if there's a device with the given device identifier.</p> <p>:param device_id: Device identifier :return: True if device exists</p>"},{"location":"api/config/#ucapi_framework.config.BaseConfigManager.add_or_update","title":"add_or_update","text":"<pre><code>add_or_update(device: DeviceT) -&gt; None\n</code></pre> <p>Add a new device or update if it already exists.</p> <p>:param device: Device configuration to add or update</p>"},{"location":"api/config/#ucapi_framework.config.BaseConfigManager.get","title":"get","text":"<pre><code>get(device_id: str) -&gt; DeviceT | None\n</code></pre> <p>Get device configuration for given identifier.</p> <p>:param device_id: Device identifier :return: Device configuration or None</p>"},{"location":"api/config/#ucapi_framework.config.BaseConfigManager.update","title":"update","text":"<pre><code>update(device: DeviceT) -&gt; bool\n</code></pre> <p>Update a configured device and persist configuration.</p> <p>:param device: Device configuration with updated values :return: True if device was updated, False if not found</p>"},{"location":"api/config/#ucapi_framework.config.BaseConfigManager.remove","title":"remove","text":"<pre><code>remove(device_id: str) -&gt; bool\n</code></pre> <p>Remove the given device configuration.</p> <p>:param device_id: Device identifier :return: True if device was removed</p>"},{"location":"api/config/#ucapi_framework.config.BaseConfigManager.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Remove all configuration.</p>"},{"location":"api/config/#ucapi_framework.config.BaseConfigManager.store","title":"store","text":"<pre><code>store() -&gt; bool\n</code></pre> <p>Store the configuration file.</p> <p>:return: True if the configuration could be saved</p>"},{"location":"api/config/#ucapi_framework.config.BaseConfigManager.load","title":"load","text":"<pre><code>load() -&gt; bool\n</code></pre> <p>Load the configuration from file.</p> <p>:return: True if the configuration could be loaded</p>"},{"location":"api/config/#ucapi_framework.config.BaseConfigManager.get_device_id","title":"get_device_id","text":"<pre><code>get_device_id(device: DeviceT) -&gt; str\n</code></pre> <p>Extract device identifier from device configuration.</p> <p>Default implementation: tries common attribute names (identifier, id, device_id). Override this if your device config uses a different attribute name.</p> <p>:param device: Device configuration :return: Device identifier :raises AttributeError: If no valid ID attribute is found</p>"},{"location":"api/config/#ucapi_framework.config.BaseConfigManager.get_backup_json","title":"get_backup_json","text":"<pre><code>get_backup_json() -&gt; str\n</code></pre> <p>Get configuration as JSON string for backup.</p> <p>:return: JSON string representation of configuration</p>"},{"location":"api/config/#ucapi_framework.config.BaseConfigManager.restore_from_backup_json","title":"restore_from_backup_json","text":"<pre><code>restore_from_backup_json(backup_json: str) -&gt; bool\n</code></pre> <p>Restore configuration from JSON string.</p> <p>:param backup_json: JSON string containing configuration backup :return: True if restore was successful</p>"},{"location":"api/config/#ucapi_framework.config.BaseConfigManager.migration_required","title":"migration_required","text":"<pre><code>migration_required() -&gt; bool\n</code></pre> <p>Check if configuration migration is required.</p> <p>Override this method to implement migration detection logic.</p> <p>:return: True if migration is required</p>"},{"location":"api/config/#ucapi_framework.config.BaseConfigManager.migrate","title":"migrate  <code>async</code>","text":"<pre><code>migrate() -&gt; bool\n</code></pre> <p>Migrate configuration if required.</p> <p>Override this method to implement migration logic.</p> <p>:return: True if migration was successful</p>"},{"location":"api/config/#ucapi_framework.config.BaseConfigManager.deserialize_device_auto","title":"deserialize_device_auto","text":"<pre><code>deserialize_device_auto(\n    data: dict, device_class: type[DeviceT]\n) -&gt; DeviceT | None\n</code></pre> <p>Automatically deserialize device configuration with nested dataclass support.</p> <p>This helper method automatically handles: - Nested dataclasses - Lists of dataclasses (e.g., list[LutronLightInfo]) - Primitive types</p> <p>Use this in your deserialize_device() implementation:</p> Example <p>def deserialize_device(self, data: dict) -&gt; MyDeviceConfig | None:     return self.deserialize_device_auto(data, MyDeviceConfig)</p> <p>For backward compatibility or custom logic, override specific fields:</p> Example <p>def deserialize_device(self, data: dict) -&gt; MyDeviceConfig | None:     # Let auto-deserialize handle nested dataclasses     device = self.deserialize_device_auto(data, MyDeviceConfig)     if device:         # Add custom migration logic         if not hasattr(device, 'new_field'):             device.new_field = \"default_value\"     return device</p> <p>:param data: Dictionary with device data :param device_class: The device dataclass type :return: Device configuration or None if invalid</p>"},{"location":"api/config/#ucapi_framework.config.BaseConfigManager.deserialize_device","title":"deserialize_device","text":"<pre><code>deserialize_device(data: dict) -&gt; DeviceT | None\n</code></pre> <p>Deserialize device configuration from dictionary.</p> <p>DEFAULT IMPLEMENTATION: Uses deserialize_device_auto() with the config class provided during initialization or inferred from the Generic type parameter.</p> <p>Most integrations can use the default implementation without overriding:</p> <pre><code>class MyConfigManager(BaseConfigManager[MyDeviceConfig]):\n    pass  # No override needed!\n</code></pre> <p>Or explicitly pass the config class:</p> <pre><code>manager = MyConfigManager(data_path, config_class=MyDeviceConfig)\n</code></pre> <p>Override only if you need custom logic:</p> <pre><code>def deserialize_device(self, data: dict) -&gt; MyDeviceConfig | None:\n    # Auto-deserialize handles nested dataclasses\n    device = self.deserialize_device_auto(data, MyDeviceConfig)\n    if device:\n        # Custom migration logic\n        if 'old_field' in data:\n            device.new_field = migrate_value(data['old_field'])\n        # Custom post-processing\n        for light in device.lights:\n            light.name = light.name.replace(\"_\", \" \")\n    return device\n</code></pre> <p>:param data: Dictionary with device data :return: Device configuration or None if invalid</p>"},{"location":"api/config/#ucapi_framework.config.BaseConfigManager.update_device_fields","title":"update_device_fields","text":"<pre><code>update_device_fields(\n    existing: DeviceT, updated: DeviceT\n) -&gt; None\n</code></pre> <p>Update fields of existing device with values from updated device.</p> <p>Default implementation updates all fields. Override for custom behavior.</p> <p>:param existing: Existing device configuration (will be modified) :param updated: Updated device configuration (source of new values)</p>"},{"location":"api/device/","title":"Device API Reference","text":"<p>Device interfaces provide base classes for different connection patterns.</p>"},{"location":"api/device/#basedeviceinterface","title":"BaseDeviceInterface","text":""},{"location":"api/device/#ucapi_framework.device.BaseDeviceInterface","title":"ucapi_framework.device.BaseDeviceInterface","text":"<pre><code>BaseDeviceInterface(\n    device_config: Any,\n    loop: AbstractEventLoop | None = None,\n    config_manager: BaseConfigManager | None = None,\n)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Base class for all device interfaces.</p> <p>Provides common functionality: - Event emitter for device state changes - Connection lifecycle management - Property accessors for device information - Logging helpers</p> <p>Create device interface instance.</p> <p>:param device_config: Device configuration :param loop: Event loop :param config_manager: Optional config manager for persisting configuration updates</p>"},{"location":"api/device/#ucapi_framework.device.BaseDeviceInterface-attributes","title":"Attributes","text":""},{"location":"api/device/#ucapi_framework.device.BaseDeviceInterface.device_config","title":"device_config  <code>property</code>","text":"<pre><code>device_config: Any\n</code></pre> <p>Return the device configuration.</p>"},{"location":"api/device/#ucapi_framework.device.BaseDeviceInterface.identifier","title":"identifier  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>identifier: str\n</code></pre> <p>Return the device identifier.</p>"},{"location":"api/device/#ucapi_framework.device.BaseDeviceInterface.name","title":"name  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Return the device name.</p>"},{"location":"api/device/#ucapi_framework.device.BaseDeviceInterface.address","title":"address  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>address: str | None\n</code></pre> <p>Return the device address.</p>"},{"location":"api/device/#ucapi_framework.device.BaseDeviceInterface.log_id","title":"log_id  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>log_id: str\n</code></pre> <p>Return a log identifier for the device.</p>"},{"location":"api/device/#ucapi_framework.device.BaseDeviceInterface.is_connected","title":"is_connected  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>is_connected: bool\n</code></pre> <p>Return True if device is currently connected, False otherwise.</p>"},{"location":"api/device/#ucapi_framework.device.BaseDeviceInterface.state","title":"state  <code>property</code>","text":"<pre><code>state: Any\n</code></pre> <p>Return the current device state.</p>"},{"location":"api/device/#ucapi_framework.device.BaseDeviceInterface-functions","title":"Functions","text":""},{"location":"api/device/#ucapi_framework.device.BaseDeviceInterface.update_config","title":"update_config","text":"<pre><code>update_config(**kwargs) -&gt; bool\n</code></pre> <p>Update device configuration attributes and persist changes.</p> <p>This method allows devices to update their configuration when runtime changes occur, such as: - New authentication tokens received - IP address changes detected - Device firmware updates changing capabilities - Dynamic configuration from device responses</p> <p>The configuration is updated both in memory and persisted to storage if a config_manager is available.</p> Example usage <p>:param kwargs: Configuration attributes to update :return: True if config was persisted successfully, False if no config_manager or update failed :raises AttributeError: If trying to update non-existent configuration attribute</p>"},{"location":"api/device/#ucapi_framework.device.BaseDeviceInterface.update_config--update-token-after-authentication","title":"Update token after authentication","text":"<p>self.update_config(token=\"new_token_value\")</p>"},{"location":"api/device/#ucapi_framework.device.BaseDeviceInterface.update_config--update-multiple-fields","title":"Update multiple fields","text":"<p>self.update_config(     address=\"192.168.1.100\",     token=\"new_token\",     firmware_version=\"2.0.1\" )</p>"},{"location":"api/device/#ucapi_framework.device.BaseDeviceInterface.connect","title":"connect  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>connect() -&gt; bool\n</code></pre> <p>Establish connection to the device.</p> <p>:return: True if connection successful, False otherwise</p>"},{"location":"api/device/#ucapi_framework.device.BaseDeviceInterface.disconnect","title":"disconnect  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from the device.</p>"},{"location":"api/device/#statelesshttpdevice","title":"StatelessHTTPDevice","text":""},{"location":"api/device/#ucapi_framework.device.StatelessHTTPDevice","title":"ucapi_framework.device.StatelessHTTPDevice","text":"<pre><code>StatelessHTTPDevice(\n    device_config: Any,\n    loop: AbstractEventLoop | None = None,\n    config_manager: BaseConfigManager | None = None,\n)\n</code></pre> <p>               Bases: <code>BaseDeviceInterface</code></p> <p>Base class for devices with stateless HTTP API.</p> <p>No persistent connection is maintained. Each command creates a new HTTP session for the request.</p> <p>Good for: REST APIs, simple HTTP devices without a persistent connection (e.g., websockets)</p> <p>Initialize stateless HTTP device.</p>"},{"location":"api/device/#ucapi_framework.device.StatelessHTTPDevice-attributes","title":"Attributes","text":""},{"location":"api/device/#ucapi_framework.device.StatelessHTTPDevice.is_connected","title":"is_connected  <code>property</code>","text":"<pre><code>is_connected: bool\n</code></pre> <p>Return True if device is currently connected.</p>"},{"location":"api/device/#ucapi_framework.device.StatelessHTTPDevice-functions","title":"Functions","text":""},{"location":"api/device/#ucapi_framework.device.StatelessHTTPDevice.connect","title":"connect  <code>async</code>","text":"<pre><code>connect() -&gt; bool\n</code></pre> <p>Establish connection (verify device is reachable).</p> <p>For stateless devices, this typically means verifying the device responds to a basic request.</p> <p>:return: True if connection successful, False otherwise</p>"},{"location":"api/device/#ucapi_framework.device.StatelessHTTPDevice.disconnect","title":"disconnect  <code>async</code>","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from device (mark as disconnected).</p>"},{"location":"api/device/#ucapi_framework.device.StatelessHTTPDevice.verify_connection","title":"verify_connection  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>verify_connection() -&gt; None\n</code></pre> <p>Verify the device connection.</p> <p>Should make a simple request to verify device is reachable. Raises exception if connection fails.</p>"},{"location":"api/device/#pollingdevice","title":"PollingDevice","text":""},{"location":"api/device/#ucapi_framework.device.PollingDevice","title":"ucapi_framework.device.PollingDevice","text":"<pre><code>PollingDevice(\n    device_config: Any,\n    loop: AbstractEventLoop | None = None,\n    poll_interval: int = 30,\n    config_manager: BaseConfigManager | None = None,\n)\n</code></pre> <p>               Bases: <code>BaseDeviceInterface</code></p> <p>Base class for devices requiring periodic status polling.</p> <p>Maintains a polling task that periodically queries the device for status updates.</p> <p>Good for: Devices without push notifications, devices with changing state</p> <p>Initialize polling device.</p> <p>:param device_config: Device configuration :param loop: Event loop :param poll_interval: Polling interval in seconds :param config_manager: Optional config manager for persisting configuration updates</p>"},{"location":"api/device/#ucapi_framework.device.PollingDevice-attributes","title":"Attributes","text":""},{"location":"api/device/#ucapi_framework.device.PollingDevice.is_connected","title":"is_connected  <code>property</code>","text":"<pre><code>is_connected: bool\n</code></pre> <p>Return True if device is currently connected and polling.</p>"},{"location":"api/device/#ucapi_framework.device.PollingDevice-functions","title":"Functions","text":""},{"location":"api/device/#ucapi_framework.device.PollingDevice.connect","title":"connect  <code>async</code>","text":"<pre><code>connect() -&gt; bool\n</code></pre> <p>Establish connection and start polling.</p> <p>:return: True if connection successful, False otherwise</p>"},{"location":"api/device/#ucapi_framework.device.PollingDevice.disconnect","title":"disconnect  <code>async</code>","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Stop polling and disconnect.</p>"},{"location":"api/device/#ucapi_framework.device.PollingDevice.establish_connection","title":"establish_connection  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>establish_connection() -&gt; None\n</code></pre> <p>Establish initial connection to device.</p> <p>Called once when connect() is invoked.</p>"},{"location":"api/device/#ucapi_framework.device.PollingDevice.poll_device","title":"poll_device  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>poll_device() -&gt; None\n</code></pre> <p>Poll the device for status updates.</p> <p>Called periodically based on poll_interval. Should emit UPDATE events with changed state.</p>"},{"location":"api/device/#websocketdevice","title":"WebSocketDevice","text":""},{"location":"api/device/#ucapi_framework.device.WebSocketDevice","title":"ucapi_framework.device.WebSocketDevice","text":"<pre><code>WebSocketDevice(\n    device_config: Any,\n    loop: AbstractEventLoop | None = None,\n    reconnect: bool = True,\n    reconnect_interval: int = BACKOFF_SEC,\n    reconnect_max: int = BACKOFF_MAX,\n    ping_interval: int = 30,\n    ping_timeout: int = 10,\n    config_manager: BaseConfigManager | None = None,\n)\n</code></pre> <p>               Bases: <code>BaseDeviceInterface</code></p> <p>Base class for devices with WebSocket connections.</p> <p>Maintains a persistent WebSocket connection with automatic reconnection, exponential backoff, and optional ping/keepalive support.</p> <p>Features: - Automatic reconnection on connection loss - Configurable exponential backoff (default: 2s initial, 30s max) - Optional ping/pong keepalive (default: 30s interval) - Graceful error handling and recovery</p> <p>Good for: Devices with WebSocket APIs, real-time updates</p> <p>Initialize WebSocket device.</p> <p>:param device_config: Device configuration :param loop: Event loop :param reconnect: Enable automatic reconnection (default: True) :param reconnect_interval: Initial reconnection interval in seconds (default: 2) :param reconnect_max: Maximum reconnection interval in seconds (default: 30) :param ping_interval: Ping/keepalive interval in seconds, 0 to disable (default: 30) :param ping_timeout: Ping timeout in seconds (default: 10) :param config_manager: Optional config manager for persisting configuration updates</p>"},{"location":"api/device/#ucapi_framework.device.WebSocketDevice-attributes","title":"Attributes","text":""},{"location":"api/device/#ucapi_framework.device.WebSocketDevice.is_connected","title":"is_connected  <code>property</code>","text":"<pre><code>is_connected: bool\n</code></pre> <p>Check if WebSocket is currently connected.</p> <p>:return: True if WebSocket is connected, False otherwise</p>"},{"location":"api/device/#ucapi_framework.device.WebSocketDevice-functions","title":"Functions","text":""},{"location":"api/device/#ucapi_framework.device.WebSocketDevice.connect","title":"connect  <code>async</code>","text":"<pre><code>connect() -&gt; bool\n</code></pre> <p>Establish WebSocket connection with automatic reconnection.</p> <p>If reconnection is enabled, this will continuously attempt to maintain a connection until disconnect() is called.</p> <p>:return: True if connection task started successfully, False otherwise</p>"},{"location":"api/device/#ucapi_framework.device.WebSocketDevice.disconnect","title":"disconnect  <code>async</code>","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Close WebSocket connection and stop reconnection attempts.</p>"},{"location":"api/device/#ucapi_framework.device.WebSocketDevice.send_ping","title":"send_ping  <code>async</code>","text":"<pre><code>send_ping() -&gt; None\n</code></pre> <p>Send ping to WebSocket connection.</p> <p>Default implementation does nothing. Override this if your WebSocket implementation requires explicit ping messages.</p> <p>For websockets library, pings are handled automatically. For custom implementations, send your protocol-specific keepalive.</p> Example for custom protocol <p>async def send_ping(self):     await self._ws.send(json.dumps({\"type\": \"ping\"}))</p>"},{"location":"api/device/#ucapi_framework.device.WebSocketDevice.create_websocket","title":"create_websocket  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>create_websocket() -&gt; Any\n</code></pre> <p>Create and return WebSocket connection.</p> <p>Called automatically by the connection loop. Raise an exception if connection cannot be established.</p> Example using websockets library <p>async def create_websocket(self):     import websockets     return await websockets.connect(         f\"ws://{self.address}/socket\",         ping_interval=None,  # We handle pings ourselves     )</p> <p>:return: WebSocket connection object</p>"},{"location":"api/device/#ucapi_framework.device.WebSocketDevice.close_websocket","title":"close_websocket  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>close_websocket() -&gt; None\n</code></pre> <p>Close the WebSocket connection.</p> Example <p>async def close_websocket(self):     if self._ws:         await self._ws.close()</p>"},{"location":"api/device/#ucapi_framework.device.WebSocketDevice.receive_message","title":"receive_message  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>receive_message() -&gt; Any\n</code></pre> <p>Receive a message from WebSocket.</p> <p>Should block until a message is available or connection is closed.</p> Example <p>async def receive_message(self):     try:         message = await self._ws.recv()         return json.loads(message)     except websockets.ConnectionClosed:         return None</p> <p>:return: Message data or None if connection closed</p>"},{"location":"api/device/#ucapi_framework.device.WebSocketDevice.handle_message","title":"handle_message  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>handle_message(message: Any) -&gt; None\n</code></pre> <p>Handle incoming WebSocket message.</p> <p>Called for each message received from the WebSocket connection.</p> <p>:param message: Message data</p>"},{"location":"api/device/#websocketpollingdevice","title":"WebSocketPollingDevice","text":""},{"location":"api/device/#ucapi_framework.device.WebSocketPollingDevice","title":"ucapi_framework.device.WebSocketPollingDevice","text":"<pre><code>WebSocketPollingDevice(\n    device_config: Any,\n    loop: AbstractEventLoop | None = None,\n    poll_interval: int = 30,\n    ping_interval: int = 30,\n    ping_timeout: int = 10,\n    keep_polling_on_disconnect: bool = True,\n    config_manager: BaseConfigManager | None = None,\n)\n</code></pre> <p>               Bases: <code>WebSocketDevice</code>, <code>PollingDevice</code></p> <p>Base class for devices with WebSocket + Polling hybrid pattern.</p> <p>Combines WebSocket for real-time updates with periodic polling for health checks and state verification. This is a common pattern for smart TVs and IoT devices where: - WebSocket provides instant notifications when device is active - Polling provides fallback health checks and state verification - REST API provides additional control endpoints</p> <p>The polling and WebSocket run concurrently and independently. By default, polling continues even when WebSocket is disconnected (via disconnect()), providing resilience and allowing fallback to polling-only mode. Use disconnect_all() or set keep_polling_on_disconnect=False to stop both.</p> <p>Implementation uses multiple inheritance to compose WebSocketDevice and PollingDevice functionality without code duplication.</p> <p>WebSocket reconnection is automatically disabled for this class since polling provides the resilience. WebSocket will reconnect naturally through the hybrid connect() implementation.</p> <p>Good for: Smart TVs, media players, IoT devices with multiple communication methods</p> <p>Initialize WebSocket + Polling device.</p> <p>:param device_config: Device configuration :param loop: Event loop :param poll_interval: Polling interval in seconds (default: 30) :param ping_interval: WebSocket ping interval in seconds, 0 to disable (default: 30) :param ping_timeout: WebSocket ping timeout in seconds (default: 10) :param keep_polling_on_disconnect: Continue polling when WebSocket disconnects (default: True) :param config_manager: Optional config manager for persisting configuration updates</p>"},{"location":"api/device/#ucapi_framework.device.WebSocketPollingDevice-attributes","title":"Attributes","text":""},{"location":"api/device/#ucapi_framework.device.WebSocketPollingDevice.is_websocket_connected","title":"is_websocket_connected  <code>property</code>","text":"<pre><code>is_websocket_connected: bool\n</code></pre> <p>Check if WebSocket is currently connected.</p> <p>:return: True if WebSocket is connected, False otherwise</p>"},{"location":"api/device/#ucapi_framework.device.WebSocketPollingDevice-functions","title":"Functions","text":""},{"location":"api/device/#ucapi_framework.device.WebSocketPollingDevice.connect","title":"connect  <code>async</code>","text":"<pre><code>connect() -&gt; bool\n</code></pre> <p>Establish WebSocket connection and start polling.</p> <p>Both WebSocket and polling tasks run concurrently. If WebSocket connection fails, polling continues to provide state updates.</p> <p>:return: True if at least polling started successfully, False otherwise</p>"},{"location":"api/device/#ucapi_framework.device.WebSocketPollingDevice.disconnect","title":"disconnect  <code>async</code>","text":"<pre><code>disconnect(stop_polling: bool | None = None) -&gt; None\n</code></pre> <p>Stop WebSocket and optionally polling.</p> <p>If keep_polling_on_disconnect is True (default) and stop_polling is not explicitly set, only the WebSocket connection is stopped and polling continues. This allows the device to fall back to polling-only mode.</p> <p>If keep_polling_on_disconnect is False or stop_polling=True, both WebSocket and polling are stopped, fully disconnecting the device.</p> <p>:param stop_polling: Override to force stop polling (True) or keep it running (False).                    If None, uses keep_polling_on_disconnect setting.</p>"},{"location":"api/device/#ucapi_framework.device.WebSocketPollingDevice.disconnect_all","title":"disconnect_all  <code>async</code>","text":"<pre><code>disconnect_all() -&gt; None\n</code></pre> <p>Stop both WebSocket and polling, fully disconnecting the device.</p> <p>This method always stops both WebSocket and polling regardless of the keep_polling_on_disconnect setting.</p>"},{"location":"api/device/#externalclientdevice","title":"ExternalClientDevice","text":""},{"location":"api/device/#ucapi_framework.device.ExternalClientDevice","title":"ucapi_framework.device.ExternalClientDevice","text":"<pre><code>ExternalClientDevice(\n    device_config: Any,\n    loop: AbstractEventLoop | None = None,\n    enable_watchdog: bool = True,\n    watchdog_interval: int = 30,\n    reconnect_delay: int = 5,\n    max_reconnect_attempts: int | None = 3,\n    config_manager: BaseConfigManager | None = None,\n)\n</code></pre> <p>               Bases: <code>BaseDeviceInterface</code></p> <p>Base class for devices using external client libraries.</p> <p>Use this when wrapping a third-party library that: - Manages its own WebSocket/TCP connection internally - Provides event callbacks for state changes - Exposes a connection state property - May disconnect without proper notification</p> <p>Features: - Watchdog polling to verify external client connection state - Automatic reconnection when watchdog detects disconnect - Configurable watchdog interval and reconnection attempts - Early exit in connect() if client is already connected</p> Z-Wave JS, Home Assistant WebSocket, MQTT clients, <p>or any library that manages its own connection.</p> <p>Initialize external client device.</p> <p>:param device_config: Device configuration :param loop: Event loop :param enable_watchdog: Enable watchdog to monitor connection state (default: True) :param watchdog_interval: Interval to check connection state (seconds) :param reconnect_delay: Delay between reconnection attempts (seconds) :param max_reconnect_attempts: Max reconnection attempts before giving up.     None = disable reconnection, 0 = infinite, positive int = limit :param config_manager: Optional config manager</p>"},{"location":"api/device/#ucapi_framework.device.ExternalClientDevice-attributes","title":"Attributes","text":""},{"location":"api/device/#ucapi_framework.device.ExternalClientDevice.is_connected","title":"is_connected  <code>property</code>","text":"<pre><code>is_connected: bool\n</code></pre> <p>Return True if device is connected.</p> <p>Checks both internal state and external client state for accuracy.</p>"},{"location":"api/device/#ucapi_framework.device.ExternalClientDevice-functions","title":"Functions","text":""},{"location":"api/device/#ucapi_framework.device.ExternalClientDevice.connect","title":"connect  <code>async</code>","text":"<pre><code>connect() -&gt; bool\n</code></pre> <p>Connect to device via external client and start watchdog.</p> <p>:return: True if connection successful, False otherwise</p>"},{"location":"api/device/#ucapi_framework.device.ExternalClientDevice.disconnect","title":"disconnect  <code>async</code>","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from device and stop watchdog.</p>"},{"location":"api/device/#ucapi_framework.device.ExternalClientDevice.create_client","title":"create_client  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>create_client() -&gt; Any\n</code></pre> <p>Create the external client instance.</p> Example <p>async def create_client(self):     return ZWaveClient(self.address)</p> <p>:return: External client instance</p>"},{"location":"api/device/#ucapi_framework.device.ExternalClientDevice.connect_client","title":"connect_client  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>connect_client() -&gt; None\n</code></pre> <p>Connect the external client.</p> <p>This is a good place to set up event handlers on the client.</p> Example <p>async def connect_client(self):     await self._client.connect()     self._client.on(\"value_updated\", self._on_value_updated)</p>"},{"location":"api/device/#ucapi_framework.device.ExternalClientDevice.disconnect_client","title":"disconnect_client  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>disconnect_client() -&gt; None\n</code></pre> <p>Disconnect the external client.</p> <p>This is a good place to remove event handlers from the client.</p> Example <p>async def disconnect_client(self):     self._client.off(\"value_updated\", self._on_value_updated)     await self._client.disconnect()</p>"},{"location":"api/device/#ucapi_framework.device.ExternalClientDevice.check_client_connected","title":"check_client_connected  <code>abstractmethod</code>","text":"<pre><code>check_client_connected() -&gt; bool\n</code></pre> <p>Check if the external client is connected.</p> <p>This should query the external client's actual connection state, not rely on internal tracking.</p> Example <p>def check_client_connected(self) -&gt; bool:     return self._client is not None and self._client.connected</p> <p>:return: True if external client is connected</p>"},{"location":"api/device/#persistentconnectiondevice","title":"PersistentConnectionDevice","text":""},{"location":"api/device/#ucapi_framework.device.PersistentConnectionDevice","title":"ucapi_framework.device.PersistentConnectionDevice","text":"<pre><code>PersistentConnectionDevice(\n    device_config: Any,\n    loop: AbstractEventLoop | None = None,\n    backoff_max: int = BACKOFF_MAX,\n    config_manager: BaseConfigManager | None = None,\n)\n</code></pre> <p>               Bases: <code>BaseDeviceInterface</code></p> <p>Base class for devices with persistent TCP/protocol connections.</p> <p>Maintains a persistent connection with reconnection logic and backoff.</p> <p>Good for: Proprietary protocols, TCP connections, devices requiring persistent sessions</p> <p>Initialize persistent connection device.</p> <p>:param device_config: Device configuration :param loop: Event loop :param backoff_max: Maximum backoff time in seconds :param config_manager: Optional config manager for persisting configuration updates</p>"},{"location":"api/device/#ucapi_framework.device.PersistentConnectionDevice-attributes","title":"Attributes","text":""},{"location":"api/device/#ucapi_framework.device.PersistentConnectionDevice.is_connected","title":"is_connected  <code>property</code>","text":"<pre><code>is_connected: bool\n</code></pre> <p>Return True if device has an active connection.</p>"},{"location":"api/device/#ucapi_framework.device.PersistentConnectionDevice-functions","title":"Functions","text":""},{"location":"api/device/#ucapi_framework.device.PersistentConnectionDevice.connect","title":"connect  <code>async</code>","text":"<pre><code>connect() -&gt; bool\n</code></pre> <p>Establish persistent connection with reconnection logic.</p> <p>:return: True if connection task started successfully, False otherwise</p>"},{"location":"api/device/#ucapi_framework.device.PersistentConnectionDevice.disconnect","title":"disconnect  <code>async</code>","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Close persistent connection.</p>"},{"location":"api/device/#ucapi_framework.device.PersistentConnectionDevice.establish_connection","title":"establish_connection  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>establish_connection() -&gt; Any\n</code></pre> <p>Establish connection to device.</p> <p>:return: Connection object</p>"},{"location":"api/device/#ucapi_framework.device.PersistentConnectionDevice.close_connection","title":"close_connection  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>close_connection() -&gt; None\n</code></pre> <p>Close the connection.</p>"},{"location":"api/device/#ucapi_framework.device.PersistentConnectionDevice.maintain_connection","title":"maintain_connection  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>maintain_connection() -&gt; None\n</code></pre> <p>Maintain the connection.</p> <p>This method should block while the connection is active. Return when connection is lost or should be closed.</p>"},{"location":"api/device/#deviceevents","title":"DeviceEvents","text":""},{"location":"api/device/#ucapi_framework.device.DeviceEvents","title":"ucapi_framework.device.DeviceEvents","text":"<p>               Bases: <code>StrEnum</code></p> <p>Common device events.</p>"},{"location":"api/discovery/","title":"Discovery API Reference","text":"<p>Discovery classes provide device discovery implementations for common protocols.</p>"},{"location":"api/discovery/#discovereddevice","title":"DiscoveredDevice","text":""},{"location":"api/discovery/#ucapi_framework.discovery.DiscoveredDevice","title":"ucapi_framework.discovery.DiscoveredDevice  <code>dataclass</code>","text":"<pre><code>DiscoveredDevice(\n    identifier: str,\n    name: str,\n    address: str,\n    extra_data: dict[str, Any] | None = None,\n)\n</code></pre> <p>Common structure for discovered devices.</p> <p>All discovery implementations should return this format.</p>"},{"location":"api/discovery/#ucapi_framework.discovery.DiscoveredDevice-attributes","title":"Attributes","text":""},{"location":"api/discovery/#ucapi_framework.discovery.DiscoveredDevice.identifier","title":"identifier  <code>instance-attribute</code>","text":"<pre><code>identifier: str\n</code></pre> <p>Unique identifier for the device (e.g., MAC address, serial number)</p>"},{"location":"api/discovery/#ucapi_framework.discovery.DiscoveredDevice.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Human-readable device name</p>"},{"location":"api/discovery/#ucapi_framework.discovery.DiscoveredDevice.address","title":"address  <code>instance-attribute</code>","text":"<pre><code>address: str\n</code></pre> <p>Device address (IP address, Bluetooth address, etc.)</p>"},{"location":"api/discovery/#ucapi_framework.discovery.DiscoveredDevice.extra_data","title":"extra_data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra_data: dict[str, Any] | None = None\n</code></pre> <p>Optional additional data specific to the discovery method</p>"},{"location":"api/discovery/#basediscovery","title":"BaseDiscovery","text":""},{"location":"api/discovery/#ucapi_framework.discovery.BaseDiscovery","title":"ucapi_framework.discovery.BaseDiscovery","text":"<pre><code>BaseDiscovery(timeout: int = 5)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Base class for device discovery.</p> <p>Provides a common interface for different discovery methods: - SSDP - mDNS/Bonjour - Bluetooth LE - Cloud API - Network scanning</p> <p>Initialize discovery.</p> <p>:param timeout: Discovery timeout in seconds</p>"},{"location":"api/discovery/#ucapi_framework.discovery.BaseDiscovery-attributes","title":"Attributes","text":""},{"location":"api/discovery/#ucapi_framework.discovery.BaseDiscovery.devices","title":"devices  <code>property</code>","text":"<pre><code>devices: list[DiscoveredDevice]\n</code></pre> <p>Get the list of discovered devices from the last discovery run.</p> <p>This property provides access to devices found by the most recent call to discover(). Useful when implementing create_device_from_discovery() in setup flows.</p> <p>:return: List of discovered devices</p>"},{"location":"api/discovery/#ucapi_framework.discovery.BaseDiscovery-functions","title":"Functions","text":""},{"location":"api/discovery/#ucapi_framework.discovery.BaseDiscovery.discover","title":"discover  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>discover() -&gt; list[DiscoveredDevice]\n</code></pre> <p>Perform device discovery.</p> <p>:return: List of discovered devices</p>"},{"location":"api/discovery/#ucapi_framework.discovery.BaseDiscovery.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Clear the list of discovered devices.</p>"},{"location":"api/discovery/#ssdpdiscovery","title":"SSDPDiscovery","text":""},{"location":"api/discovery/#ucapi_framework.discovery.SSDPDiscovery","title":"ucapi_framework.discovery.SSDPDiscovery","text":"<pre><code>SSDPDiscovery(\n    search_target: str = \"ssdp:all\",\n    timeout: int = 5,\n    device_filter: Callable | None = None,\n)\n</code></pre> <p>               Bases: <code>BaseDiscovery</code></p> <p>SSDP-based device discovery.</p> <p>Uses Simple Service Discovery Protocol to find devices on the local network. Good for: UPnP devices, media renderers, smart TVs</p> <p>Initialize SSDP discovery.</p> <p>:param search_target: SSDP search target (e.g., \"ssdp:all\", \"urn:schemas-upnp-org:device:MediaRenderer:1\") :param timeout: Discovery timeout in seconds :param device_filter: Optional filter function to filter discovered devices</p>"},{"location":"api/discovery/#ucapi_framework.discovery.SSDPDiscovery-functions","title":"Functions","text":""},{"location":"api/discovery/#ucapi_framework.discovery.SSDPDiscovery.discover","title":"discover  <code>async</code>","text":"<pre><code>discover() -&gt; list[DiscoveredDevice]\n</code></pre> <p>Perform SSDP discovery.</p> <p>:return: List of discovered devices</p>"},{"location":"api/discovery/#ucapi_framework.discovery.SSDPDiscovery.parse_ssdp_device","title":"parse_ssdp_device  <code>abstractmethod</code>","text":"<pre><code>parse_ssdp_device(\n    raw_device: dict,\n) -&gt; DiscoveredDevice | None\n</code></pre> <p>Parse raw SSDP device data into DiscoveredDevice.</p> <p>Override this method to extract device information from SSDP response.</p> <p>:param raw_device: Raw SSDP device data :return: DiscoveredDevice or None if parsing fails</p>"},{"location":"api/discovery/#sddpdiscovery","title":"SDDPDiscovery","text":""},{"location":"api/discovery/#ucapi_framework.discovery.SDDPDiscovery","title":"ucapi_framework.discovery.SDDPDiscovery","text":"<pre><code>SDDPDiscovery(\n    search_pattern: str = \"*\",\n    timeout: int = 5,\n    multicast_address: str | None = None,\n    multicast_port: int | None = None,\n    bind_addresses: list[str] | None = None,\n    include_loopback: bool = False,\n)\n</code></pre> <p>               Bases: <code>BaseDiscovery</code></p> <p>SDDP-based device discovery.</p> <p>Uses Simple Device Discovery Protocol (similar to SSDP but with different format). Good for: Samsung TVs and other devices using SDDP protocol</p> <p>Initialize SDDP discovery.</p> <p>:param search_pattern: SDDP search pattern (default: \"*\" for all devices) :param timeout: Discovery timeout in seconds :param multicast_address: SDDP multicast address (uses default if None) :param multicast_port: SDDP multicast port (uses default if None) :param bind_addresses: Optional list of specific addresses to bind to :param include_loopback: Whether to include loopback interface</p>"},{"location":"api/discovery/#ucapi_framework.discovery.SDDPDiscovery-functions","title":"Functions","text":""},{"location":"api/discovery/#ucapi_framework.discovery.SDDPDiscovery.discover","title":"discover  <code>async</code>","text":"<pre><code>discover() -&gt; list[DiscoveredDevice]\n</code></pre> <p>Perform SDDP discovery.</p> <p>:return: List of discovered devices</p>"},{"location":"api/discovery/#ucapi_framework.discovery.SDDPDiscovery.parse_sddp_response","title":"parse_sddp_response  <code>abstractmethod</code>","text":"<pre><code>parse_sddp_response(\n    datagram: Any, response_info: Any\n) -&gt; DiscoveredDevice | None\n</code></pre> <p>Parse SDDP response into DiscoveredDevice.</p> <p>Override this method to extract device information from SDDP response. The datagram contains device information in its headers (hdr_from, hdr_type, etc.).</p> Example implementation <p>def parse_sddp_response(self, datagram, response_info):     return DiscoveredDevice(         identifier=datagram.hdr_type,  # or other unique field         name=datagram.hdr_type,         address=datagram.hdr_from[0],  # IP address         extra_data={             \"type\": datagram.hdr_type,             \"datagram\": datagram,         }     )</p> <p>:param datagram: SDDP datagram with headers (hdr_from, hdr_type, etc.) :param response_info: Full response info object from SDDP client :return: DiscoveredDevice or None if parsing fails</p>"},{"location":"api/discovery/#mdnsdiscovery","title":"MDNSDiscovery","text":""},{"location":"api/discovery/#ucapi_framework.discovery.MDNSDiscovery","title":"ucapi_framework.discovery.MDNSDiscovery","text":"<pre><code>MDNSDiscovery(service_type: str, timeout: int = 5)\n</code></pre> <p>               Bases: <code>BaseDiscovery</code></p> <p>mDNS/Bonjour-based device discovery.</p> <p>Uses multicast DNS to discover devices advertising services. Good for: Apple devices, HomeKit, Chromecast, many IoT devices</p> <p>Initialize mDNS discovery.</p> <p>:param service_type: mDNS service type (e.g., \"_airplay._tcp.local.\", \"_googlecast._tcp.local.\") :param timeout: Discovery timeout in seconds</p>"},{"location":"api/discovery/#ucapi_framework.discovery.MDNSDiscovery-functions","title":"Functions","text":""},{"location":"api/discovery/#ucapi_framework.discovery.MDNSDiscovery.discover","title":"discover  <code>async</code>","text":"<pre><code>discover() -&gt; list[DiscoveredDevice]\n</code></pre> <p>Perform mDNS discovery.</p> <p>:return: List of discovered devices</p>"},{"location":"api/discovery/#ucapi_framework.discovery.MDNSDiscovery.parse_mdns_service","title":"parse_mdns_service  <code>abstractmethod</code>","text":"<pre><code>parse_mdns_service(\n    service_info: Any,\n) -&gt; DiscoveredDevice | None\n</code></pre> <p>Parse mDNS service info into DiscoveredDevice.</p> <p>Override this method to extract device information from mDNS service.</p> <p>:param service_info: mDNS service info object :return: DiscoveredDevice or None if parsing fails</p>"},{"location":"api/discovery/#networkscandiscovery","title":"NetworkScanDiscovery","text":""},{"location":"api/discovery/#ucapi_framework.discovery.NetworkScanDiscovery","title":"ucapi_framework.discovery.NetworkScanDiscovery","text":"<pre><code>NetworkScanDiscovery(\n    ip_range: str, ports: list[int], timeout: int = 5\n)\n</code></pre> <p>               Bases: <code>BaseDiscovery</code></p> <p>Network scanning-based device discovery.</p> <p>Scans IP range for devices responding on specific ports. Good for: Devices without standard discovery protocols</p> <p>Initialize network scan discovery.</p> <p>:param ip_range: IP range to scan (e.g., \"192.168.1.0/24\") :param ports: List of ports to check :param timeout: Discovery timeout in seconds</p>"},{"location":"api/discovery/#ucapi_framework.discovery.NetworkScanDiscovery-functions","title":"Functions","text":""},{"location":"api/discovery/#ucapi_framework.discovery.NetworkScanDiscovery.discover","title":"discover  <code>async</code>","text":"<pre><code>discover() -&gt; list[DiscoveredDevice]\n</code></pre> <p>Perform network scan discovery.</p> <p>:return: List of discovered devices</p>"},{"location":"api/discovery/#ucapi_framework.discovery.NetworkScanDiscovery.probe_device","title":"probe_device  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>probe_device(ip: str, port: int) -&gt; DiscoveredDevice | None\n</code></pre> <p>Probe a specific IP:port for device information.</p> <p>Override this method to implement device probing logic.</p> <p>:param ip: IP address to probe :param port: Port to probe :return: DiscoveredDevice or None if not a valid device</p>"},{"location":"api/driver/","title":"Driver API Reference","text":"<p>The driver is the central coordinator for your integration, managing device lifecycle, entity registration, and Remote events.</p>"},{"location":"api/driver/#baseintegrationdriver","title":"BaseIntegrationDriver","text":""},{"location":"api/driver/#ucapi_framework.driver.BaseIntegrationDriver","title":"ucapi_framework.driver.BaseIntegrationDriver","text":"<pre><code>BaseIntegrationDriver(\n    device_class: type[DeviceT],\n    entity_classes: list[type[Entity]] | type[Entity],\n    require_connection_before_registry: bool = False,\n    loop: AbstractEventLoop | None = None,\n    driver_id: str | None = None,\n)\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[DeviceT, ConfigT]</code></p> <p>Base class for Remote Two integration drivers.</p> <p>Handles common patterns like: - Event listeners (connect, disconnect, standby, subscribe/unsubscribe) - Device lifecycle management - Entity registration and updates - State propagation from devices to entities</p> <p>          Class Type Parameters:        </p> Name Bound or Constraints Description Default <code>DeviceT</code> <p>The device interface class (e.g., YamahaAVR)</p> required <code>ConfigT</code> <p>The device configuration class (e.g., YamahaDevice)</p> required <p>Initialize the integration driver.</p> <p>:param device_class: The device interface class to instantiate :param entity_classes: Entity class or list of entity classes (e.g., MediaPlayer, Light)                        Single entity class will be converted to a list :param require_connection_before_registry: If True, ensure device connection                                            before subscribing to entities and re-register                                            available entities after connection. Useful for hub-based                                            integrations that populate entities dynamically on connection. :param loop: The asyncio event loop (optional, defaults to asyncio.get_running_loop()) :param driver_id: Optional driver/integration ID. Used for entity ID migration to automatically                  fetch the current version from the Remote, eliminating manual entry during upgrades.</p>"},{"location":"api/driver/#ucapi_framework.driver.BaseIntegrationDriver-functions","title":"Functions","text":""},{"location":"api/driver/#ucapi_framework.driver.BaseIntegrationDriver.on_r2_connect_cmd","title":"on_r2_connect_cmd  <code>async</code>","text":"<pre><code>on_r2_connect_cmd() -&gt; None\n</code></pre> <p>Handle Remote Two connect command.</p> <p>Default implementation: connects all configured devices and sets integration state. Override to add custom logic before/after device connections.</p> Example <p>async def on_r2_connect_cmd(self) -&gt; None:     await super().on_r2_connect_cmd()     # Custom logic after connect</p>"},{"location":"api/driver/#ucapi_framework.driver.BaseIntegrationDriver.on_r2_disconnect_cmd","title":"on_r2_disconnect_cmd  <code>async</code>","text":"<pre><code>on_r2_disconnect_cmd() -&gt; None\n</code></pre> <p>Handle Remote Two disconnect command.</p> <p>Default implementation: disconnects all configured devices. Override to add custom disconnect logic.</p>"},{"location":"api/driver/#ucapi_framework.driver.BaseIntegrationDriver.on_r2_enter_standby","title":"on_r2_enter_standby  <code>async</code>","text":"<pre><code>on_r2_enter_standby() -&gt; None\n</code></pre> <p>Handle Remote Two entering standby mode.</p> <p>Default implementation: disconnects all devices to save resources. Override to customize standby behavior.</p>"},{"location":"api/driver/#ucapi_framework.driver.BaseIntegrationDriver.on_r2_exit_standby","title":"on_r2_exit_standby  <code>async</code>","text":"<pre><code>on_r2_exit_standby() -&gt; None\n</code></pre> <p>Handle Remote Two exiting standby mode.</p> <p>Default implementation: reconnects all configured devices. Override to customize wake behavior.</p>"},{"location":"api/driver/#ucapi_framework.driver.BaseIntegrationDriver.on_subscribe_entities","title":"on_subscribe_entities  <code>async</code>","text":"<pre><code>on_subscribe_entities(entity_ids: list[str]) -&gt; None\n</code></pre> <p>Handle entity subscription events.</p> <p>Default implementation handles two scenarios:</p> <p>Standard integrations (require_connection_before_registry=False): - Adds devices for subscribed entities (with background connect) - Calls refresh_entity_state() for each entity</p> <p>Hub-based integrations (require_connection_before_registry=True): - If device not configured: adds device, connects, then calls async_register_available_entities() - If device configured but not connected: connects with retries, then calls async_register_available_entities() - Calls refresh_entity_state() for each entity</p> <p>Override refresh_entity_state() for custom state refresh logic. Override async_register_available_entities() for hub-based entity population.</p> <p>:param entity_ids: List of entity identifiers being subscribed</p>"},{"location":"api/driver/#ucapi_framework.driver.BaseIntegrationDriver.on_unsubscribe_entities","title":"on_unsubscribe_entities  <code>async</code>","text":"<pre><code>on_unsubscribe_entities(entity_ids: list[str]) -&gt; None\n</code></pre> <p>Handle entity unsubscription events.</p> <p>Default implementation: disconnects and cleans up devices when all their entities are unsubscribed. Override to customize cleanup behavior.</p> <p>:param entity_ids: List of entity identifiers being unsubscribed</p>"},{"location":"api/driver/#ucapi_framework.driver.BaseIntegrationDriver.add_configured_device","title":"add_configured_device","text":"<pre><code>add_configured_device(\n    device_config: ConfigT, connect: bool = True\n) -&gt; None\n</code></pre> <p>Add and configure a device (non-blocking).</p> <p>This method adds a device to the configured devices list and registers its available entities. If connect=True, it will start a background connection task (non-blocking).</p> <p>Use this for normal device addition where you don't need to wait for connection to complete. For hub-based integrations that need to wait for connection before registering entities, use async_add_configured_device().</p> <p>:param device_config: Device configuration :param connect: Whether to initiate connection immediately (as background task)</p>"},{"location":"api/driver/#ucapi_framework.driver.BaseIntegrationDriver.setup_device_event_handlers","title":"setup_device_event_handlers","text":"<pre><code>setup_device_event_handlers(device: DeviceT) -&gt; None\n</code></pre> <p>Attach event handlers to device.</p> <p>Override this method to add custom event handlers. Call super() first to register the default handlers, then add your custom ones.</p> <p>:param device: Device instance</p>"},{"location":"api/driver/#ucapi_framework.driver.BaseIntegrationDriver.register_available_entities","title":"register_available_entities","text":"<pre><code>register_available_entities(\n    device_config: ConfigT, device: DeviceT\n) -&gt; None\n</code></pre> <p>Register available entities for a device.</p> <p>Override this method to customize entity registration logic. Call super() to use the default implementation that calls create_entities().</p> <p>:param device_config: Device configuration :param device: Device instance</p>"},{"location":"api/driver/#ucapi_framework.driver.BaseIntegrationDriver.on_device_connected","title":"on_device_connected  <code>async</code>","text":"<pre><code>on_device_connected(device_id: str) -&gt; None\n</code></pre> <p>Handle device connection.</p> <p>:param device_id: Device identifier</p>"},{"location":"api/driver/#ucapi_framework.driver.BaseIntegrationDriver.on_device_disconnected","title":"on_device_disconnected  <code>async</code>","text":"<pre><code>on_device_disconnected(device_id: str) -&gt; None\n</code></pre> <p>Handle device disconnection.</p> <p>:param device_id: Device identifier</p>"},{"location":"api/driver/#ucapi_framework.driver.BaseIntegrationDriver.on_device_connection_error","title":"on_device_connection_error  <code>async</code>","text":"<pre><code>on_device_connection_error(\n    device_id: str, message: str\n) -&gt; None\n</code></pre> <p>Handle device connection error.</p> <p>:param device_id: Device identifier :param message: Error message</p>"},{"location":"api/driver/#ucapi_framework.driver.BaseIntegrationDriver.on_device_update","title":"on_device_update  <code>async</code>","text":"<pre><code>on_device_update(\n    entity_id: str,\n    update: dict[str, Any] | None,\n    clear_media_when_off: bool = True,\n) -&gt; None\n</code></pre> <p>Handle device state updates.</p> <p>Default implementation extracts entity-type-specific attributes from the update dict and updates configured/available entities accordingly. Override this method to customize update handling or add state mapping.</p> <p>:param device_id: Device identifier :param update: Dictionary containing updated properties :param clear_media_when_off: If True, clears all media player attributes when state is OFF</p>"},{"location":"api/driver/#ucapi_framework.driver.BaseIntegrationDriver.get_device_config","title":"get_device_config","text":"<pre><code>get_device_config(device_id: str) -&gt; ConfigT | None\n</code></pre> <p>Get device configuration for the given device ID.</p> <p>Default implementation: checks _configured_devices first, then falls back to self._config_manager.get() if config manager is available. Override this if your integration uses a different config structure.</p> <p>:param device_id: Device identifier :return: Device configuration or None</p>"},{"location":"api/driver/#ucapi_framework.driver.BaseIntegrationDriver.get_device_id","title":"get_device_id","text":"<pre><code>get_device_id(device_config: ConfigT) -&gt; str\n</code></pre> <p>Extract device ID from device configuration.</p> <p>Default implementation: tries common attribute names (identifier, id, device_id). Override this if your config uses a different attribute name.</p> <p>:param device_config: Device configuration :return: Device identifier :raises AttributeError: If no valid ID attribute is found</p>"},{"location":"api/driver/#ucapi_framework.driver.BaseIntegrationDriver.get_device_name","title":"get_device_name","text":"<pre><code>get_device_name(device_config: ConfigT) -&gt; str\n</code></pre> <p>Extract device name from device configuration.</p> <p>Default implementation: tries common attribute names (name, friendly_name, device_name). Override this if your config uses a different attribute name.</p> <p>:param device_config: Device configuration :return: Device name :raises AttributeError: If no valid name attribute is found</p>"},{"location":"api/driver/#ucapi_framework.driver.BaseIntegrationDriver.get_device_address","title":"get_device_address","text":"<pre><code>get_device_address(device_config: ConfigT) -&gt; str\n</code></pre> <p>Extract device address from device configuration.</p> <p>Default implementation: tries common attribute names (address, host_address, ip_address, device_address, host). Override this if your config uses a different attribute name.</p> <p>:param device_config: Device configuration :return: Device address :raises AttributeError: If no valid address attribute is found</p>"},{"location":"api/driver/#ucapi_framework.driver.BaseIntegrationDriver.create_entities","title":"create_entities","text":"<pre><code>create_entities(\n    device_config: ConfigT, device: DeviceT\n) -&gt; list[Entity]\n</code></pre> <p>Create entity instances for a device.</p> <p>DEFAULT IMPLEMENTATION: Creates one instance per entity class passed to init, calling each as: entity_class(device_config, device)</p> <p>This works automatically for simple integrations. Override this method only when you need: - Variable entity counts (e.g., multi-zone receivers) - Hub-based discovery with runtime entity creation - Conditional entity creation based on device capabilities - Custom parameters beyond (device_config, device)</p> Example - Multi-zone receiver <p>def create_entities(self, device_config, device):     entities = []     for zone in device_config.zones:         entities.append(AnthemMediaPlayer(             entity_id=f\"media_player.{device_config.id}zone\",             device=device,             device_config=device_config,             zone_config=zone  # Custom parameter         ))     return entities</p> Example - Conditional creation <p>def create_entities(self, device_config, device):     entities = []     if device.supports_playback:         entities.append(YamahaMediaPlayer(device_config, device))     if device.supports_remote:         entities.append(YamahaRemote(device_config, device))     return entities</p> <p>:param device_config: Device configuration :param device: Device instance :return: List of entity instances (MediaPlayer, Remote, etc.)</p>"},{"location":"api/driver/#ucapi_framework.driver.BaseIntegrationDriver.map_device_state","title":"map_device_state","text":"<pre><code>map_device_state(device_state: Any) -&gt; media_player.States\n</code></pre> <p>Map device-specific state to ucapi media player state.</p> <p>DEFAULT IMPLEMENTATION: Converts device_state to uppercase string and maps common state values to media_player.States:</p> <ul> <li>UNAVAILABLE \u2192 UNAVAILABLE</li> <li>UNKNOWN \u2192 UNKNOWN</li> <li>ON, MENU, IDLE, ACTIVE, READY \u2192 ON</li> <li>OFF, POWER_OFF, POWERED_OFF \u2192 OFF</li> <li>PLAYING, PLAY \u2192 PLAYING</li> <li>PAUSED, PAUSE \u2192 PAUSED</li> <li>STANDBY, SLEEP \u2192 STANDBY</li> <li>BUFFERING, LOADING \u2192 BUFFERING</li> <li>Everything else \u2192 UNKNOWN</li> </ul> <p>Override this method if you need: - Different state mappings - Device-specific state enum handling - Complex state logic</p> Example override <p>def map_device_state(self, device_state):     if isinstance(device_state, MyDeviceState):         match device_state:             case MyDeviceState.POWERED_ON:                 return media_player.States.ON             case MyDeviceState.POWERED_OFF:                 return media_player.States.OFF             case _:                 return media_player.States.UNKNOWN     return super().map_device_state(device_state)</p> <p>:param device_state: Device-specific state (string, enum, or any object with str) :return: Media player state</p>"},{"location":"api/driver/#ucapi_framework.driver.BaseIntegrationDriver.device_from_entity_id","title":"device_from_entity_id","text":"<pre><code>device_from_entity_id(entity_id: str) -&gt; str | None\n</code></pre> <p>Extract device identifier from entity identifier.</p> <p>DEFAULT IMPLEMENTATION: Parses entity IDs using the configured separator (defaults to \".\"). Handles both formats: - Simple: \"entity_type.device_id\" \u2192 returns \"device_id\" - With sub-entity: \"entity_type.device_id.entity_id\" \u2192 returns \"device_id\"</p> <p>If you use a custom entity ID format that doesn't use the standard separator, either: 1. Set <code>driver.entity_id_separator</code> to your custom separator, OR 2. Override this method to parse your custom format</p> Example with custom separator <p>def init(self, ...):     super().init(...)     self.entity_id_separator = \"_\"  # Use underscore instead of period</p> Example custom override <p>def device_from_entity_id(self, entity_id: str) -&gt; str | None:     # For PSN, entity_id IS the device_id     return entity_id</p> <p>:param entity_id: Entity identifier (e.g., \"media_player.device_123\") :return: Device identifier or None :raises ValueError: If entity_id doesn't contain the expected separator</p>"},{"location":"api/driver/#ucapi_framework.driver.BaseIntegrationDriver.get_entity_ids_for_device","title":"get_entity_ids_for_device","text":"<pre><code>get_entity_ids_for_device(device_id: str) -&gt; list[str]\n</code></pre> <p>Get all entity identifiers for a device.</p> <p>DEFAULT IMPLEMENTATION: Queries all registered entities from the API and filters them by device_id using device_from_entity_id().</p> <p>This works automatically with the standard entity ID format from create_entity_id(). For integrations using custom entity ID formats, this will work as long as device_from_entity_id() is properly overridden to parse your custom format.</p> <p>Override this method only if you need: - Performance optimization for integrations with many entities - Special filtering logic beyond device_id matching - Caching or pre-computed entity lists</p> Example override for performance <p>def get_entity_ids_for_device(self, device_id: str) -&gt; list[str]:     # Cache entity IDs per device for faster lookups     if device_id not in self._entity_cache:         self._entity_cache[device_id] = [             f\"media_player.{device_id}\",             f\"remote.{device_id}\",         ]     return self._entity_cache[device_id]</p> <p>:param device_id: Device identifier :return: List of entity identifiers for this device</p>"},{"location":"api/driver/#ucapi_framework.driver.BaseIntegrationDriver.remove_device","title":"remove_device","text":"<pre><code>remove_device(device_id: str) -&gt; None\n</code></pre> <p>Remove a configured device.</p> <p>:param device_id: Device identifier</p>"},{"location":"api/driver/#ucapi_framework.driver.BaseIntegrationDriver.clear_devices","title":"clear_devices","text":"<pre><code>clear_devices() -&gt; None\n</code></pre> <p>Remove all configured devices.</p>"},{"location":"api/driver/#ucapi_framework.driver.BaseIntegrationDriver.on_device_added","title":"on_device_added","text":"<pre><code>on_device_added(device_config: ConfigT) -&gt; None\n</code></pre> <p>Handle a newly added device in the configuration.</p> <p>Default implementation: - If require_connection_before_registry=True: schedules async_add_configured_device   as a background task (connects and registers entities after connection) - Otherwise: adds the device without connecting</p> <p>Override if you need custom behavior.</p> <p>:param device_config: Device configuration that was added</p>"},{"location":"api/driver/#ucapi_framework.driver.BaseIntegrationDriver.on_device_removed","title":"on_device_removed","text":"<pre><code>on_device_removed(device_config: ConfigT | None) -&gt; None\n</code></pre> <p>Handle a removed device in the configuration.</p> <p>Default implementation: Removes the device or clears all if None. Override if you need custom behavior.</p> <p>:param device_config: Device configuration that was removed, or None to clear all</p>"},{"location":"api/driver/#helper-functions","title":"Helper Functions","text":""},{"location":"api/driver/#ucapi_framework.driver.create_entity_id","title":"ucapi_framework.driver.create_entity_id","text":"<pre><code>create_entity_id(\n    entity_type: EntityTypes | str,\n    device_id: str,\n    sub_device_id: str | None = None,\n) -&gt; str\n</code></pre> <p>Create a unique entity identifier for the given device and entity type.</p> <p>Entity IDs follow the format: - Simple: \"{entity_type}.{device_id}\" - With sub-device: \"{entity_type}.{device_id}.{sub_device_id}\"</p> <p>Use the optional sub_device_id parameter for devices that expose multiple entities of the same type, such as a hub with multiple lights or zones.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; create_entity_id(EntityTypes.MEDIA_PLAYER, \"device_123\")\n'media_player.device_123'\n&gt;&gt;&gt; create_entity_id(EntityTypes.LIGHT, \"hub_1\", \"light_bedroom\")\n'light.hub_1.light_bedroom'\n&gt;&gt;&gt; create_entity_id(\"media_player\", \"receiver_abc\", \"zone_2\")\n'media_player.receiver_abc.zone_2'\n</code></pre> <p>:param entity_type: The entity type (EntityTypes enum or string) :param device_id: The device identifier (hub or parent device) :param sub_device_id: Optional sub-device identifier (e.g., light ID, zone ID) :return: Entity identifier in the format \"entity_type.device_id\" or \"entity_type.device_id.sub_device_id\"</p>"},{"location":"api/setup/","title":"Setup Flow API Reference","text":"<p>The setup flow handles user interaction for device configuration and discovery.</p>"},{"location":"api/setup/#basesetupflow","title":"BaseSetupFlow","text":""},{"location":"api/setup/#ucapi_framework.setup.BaseSetupFlow","title":"ucapi_framework.setup.BaseSetupFlow","text":"<pre><code>BaseSetupFlow(\n    config_manager: BaseConfigManager,\n    *,\n    driver: BaseIntegrationDriver | None = None,\n    device_class: type | None = None,\n    discovery: BaseDiscovery | None = None,\n    show_migration_in_ui: bool = False,\n    migration_testing_mode: bool = True,\n)\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[ConfigT]</code></p> <p>Base class for integration setup flows.</p> <p>Handles common patterns: - Configuration mode (add/update/remove/reset) - Device discovery with manual fallback - Device creation and validation - State machine management</p> <p>          Class Type Parameters:        </p> Name Bound or Constraints Description Default <code>ConfigT</code> <p>The device configuration class</p> required <p>Initialize the setup flow.</p> <p>Child classes typically don't need to override init - the driver, device_class, and discovery are set automatically by create_handler().</p> <p>:param config_manager: Device configuration manager instance :param driver: Reference to the driver instance (provides access to driver state) :param device_class: The device class (enables calling class methods for validation) :param discovery: Discovery instance for auto-discovery.                  Pass None if the device does not support discovery.                  This is typically instantiated in your driver's main() and                  passed via create_handler(). :param show_migration_in_ui: Whether to show migration option in configuration mode.                             Default is False (hidden). Set to True for debugging/testing. :param migration_testing_mode: If True, migration executes all logic but skips PATCH calls.                                TEMPORARY PARAMETER - Will be removed before final release                                Default is False.</p>"},{"location":"api/setup/#ucapi_framework.setup.BaseSetupFlow-functions","title":"Functions","text":""},{"location":"api/setup/#ucapi_framework.setup.BaseSetupFlow.create_handler","title":"create_handler  <code>classmethod</code>","text":"<pre><code>create_handler(\n    driver: BaseIntegrationDriver,\n    discovery: BaseDiscovery | None = None,\n)\n</code></pre> <p>Create a setup handler function with the given configuration.</p> <p>This is a convenience factory method that creates a closure containing the setup flow instance, suitable for passing to IntegrationAPI.init().</p> <p>The driver_id is automatically extracted from the driver instance. If the driver has a driver_id set, it will be used to automatically fetch the current version from the Remote during migration.</p> <p>Example usage in driver's main():     discovery = MyDiscovery(api_key=\"...\", timeout=30)     setup_handler = MySetupFlow.create_handler(driver, discovery=discovery)     api.init(\"driver-name\", setup_handler=setup_handler)</p> <p>:param driver: The driver instance. The config_manager and driver_id will be               retrieved from the driver. :param discovery: Optional initialized discovery instance for auto-discovery.                  Pass None if the device does not support discovery. :return: Async function that handles SetupDriver messages</p>"},{"location":"api/setup/#ucapi_framework.setup.BaseSetupFlow.handle_driver_setup","title":"handle_driver_setup  <code>async</code>","text":"<pre><code>handle_driver_setup(msg: SetupDriver) -&gt; SetupAction\n</code></pre> <p>Main dispatcher for setup requests.</p> <p>:param msg: Setup driver request object :return: Setup action on how to continue</p>"},{"location":"api/setup/#ucapi_framework.setup.BaseSetupFlow.query_device","title":"query_device  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>query_device(\n    input_values: dict[str, Any],\n) -&gt; ConfigT | SetupError | RequestUserInput\n</code></pre> <p>Query and validate device using collected information.</p> <p>This method is called after the user provides device information (via manual entry or discovery). This is where you typically have enough info to query the device, validate connectivity, fetch additional data, or perform authentication.</p> <p>Using Device Class for Validation:</p> <p>The framework provides <code>self.device_class</code> which you can use to call class methods for validation. This keeps validation logic with your device class:</p> <pre><code>class MyDevice(StatelessHTTPDevice):\n    @classmethod\n    async def validate_connection(cls, host: str, token: str) -&gt; dict:\n        '''Validate credentials and return device info.'''\n        async with aiohttp.ClientSession() as session:\n            async with session.get(f\"http://{host}/api/info\",\n                                   headers={\"Token\": token}) as resp:\n                if resp.status != 200:\n                    raise ConnectionError(\"Invalid credentials\")\n                return await resp.json()\n\n# In your setup flow:\nasync def query_device(self, input_values):\n    try:\n        info = await self.device_class.validate_connection(\n            host=input_values[\"host\"],\n            token=input_values[\"token\"]\n        )\n        return MyDeviceConfig(\n            identifier=info[\"device_id\"],\n            name=info[\"name\"],\n            host=input_values[\"host\"],\n            token=input_values[\"token\"]\n        )\n    except ConnectionError:\n        return SetupError(error_type=IntegrationSetupError.CONNECTION_REFUSED)\n</code></pre> <p>Based on the query results, you can: - Return a complete device config to finish setup - Show additional screens to collect more information - Return an error if validation fails</p> <p>This method can return: - ConfigT: A valid device configuration - if no additional screens needed, setup completes.               If you need additional screens, DON'T return the config - store it in               self._pending_device_config and return RequestUserInput instead. - SetupError: An error to abort the setup with an error message - RequestUserInput: A screen to display for additional configuration or validation.                        IMPORTANT: To show additional screens after this one, you MUST                        set self._pending_device_config BEFORE returning RequestUserInput.                        The response will then route to handle_additional_configuration_response().</p> <p>Example - Simple case (no additional screens):     async def query_device(self, input_values):         # Query the device to validate connectivity         device_info = await self.api.get_device_info(input_values[\"host\"])</p> <pre><code>    if not device_info:\n        return SetupError(error_type=IntegrationSetupError.CONNECTION_REFUSED)\n\n    # Just return the config - setup completes automatically\n    return MyDeviceConfig(\n        identifier=device_info[\"id\"],\n        name=input_values[\"name\"],\n        address=input_values[\"host\"],\n        port=int(input_values.get(\"port\", 8080)),\n        version=device_info[\"version\"]\n    )\n</code></pre> Example - With validation <p>async def query_device(self, input_values):     host = input_values.get(\"host\", \"\").strip()     if not host:         return SetupError(error_type=IntegrationSetupError.CONNECTION_REFUSED)</p> <pre><code># Test connection\nif not await self.api.test_connection(host):\n    return SetupError(error_type=IntegrationSetupError.CONNECTION_REFUSED)\n\nreturn MyDeviceConfig(\n    identifier=host,\n    name=input_values.get(\"name\", host),\n    address=host\n)\n</code></pre> <p>Example - Multi-screen flow (query device, then show additional options):     async def query_device(self, input_values):         # Query the device API to validate and fetch available options         auth_response = await self.api.authenticate(             input_values[\"host\"],             input_values[\"token\"]         )</p> <pre><code>    if not auth_response[\"valid\"]:\n        return SetupError(error_type=IntegrationSetupError.AUTHORIZATION_ERROR)\n\n    # IMPORTANT: Store config in _pending_device_config for multi-screen flows\n    self._pending_device_config = MyDeviceConfig(\n        identifier=input_values[\"host\"],\n        name=input_values[\"name\"],\n        token=auth_response[\"token\"],\n        available_servers=auth_response[\"servers\"]  # Data needed for next screen\n    )\n\n    # Return screen - response will route to handle_additional_configuration_response\n    return RequestUserInput(\n        {\"en\": \"Select Server\"},\n        [{\"id\": \"server\", \"label\": {\"en\": \"Server\"},\n          \"field\": {\"dropdown\": {\"items\": self._build_server_dropdown()}}}]\n    )\n\nasync def handle_additional_configuration_response(self, msg):\n    # Access stored config and new input\n    self._pending_device_config.server = msg.input_values[\"server\"]\n    return None  # Save and complete (or return modified config)\n</code></pre> Example - Re-display form with validation error <p>async def query_device(self, input_values):     host = input_values.get(\"host\", \"\").strip()     if not host:         # Show the form again with error (no _pending_device_config set)         return RequestUserInput(             {\"en\": \"Invalid Input\"},             [                 {\"id\": \"error\", \"label\": {\"en\": \"Error\"},                  \"field\": {\"label\": {\"value\": {\"en\": \"Host is required\"}}}},                 # ... rest of the form fields             ]         )</p> <pre><code>return MyDeviceConfig(identifier=host, name=host, address=host)\n</code></pre> <p>:param input_values: User input values from the manual entry form.                     Also includes self._pre_discovery_data if pre-discovery screens were shown. :return: Device configuration, SetupError, or RequestUserInput to re-display form</p>"},{"location":"api/setup/#ucapi_framework.setup.BaseSetupFlow.get_manual_entry_form","title":"get_manual_entry_form  <code>abstractmethod</code>","text":"<pre><code>get_manual_entry_form() -&gt; RequestUserInput\n</code></pre> <p>Get the manual entry form.</p> <p>:return: RequestUserInput with manual entry fields</p>"},{"location":"api/setup/#ucapi_framework.setup.BaseSetupFlow.discover_devices","title":"discover_devices  <code>async</code>","text":"<pre><code>discover_devices() -&gt; list[DiscoveredDevice]\n</code></pre> <p>Perform device discovery.</p> <p>DEFAULT IMPLEMENTATION: Calls self.discovery.discover() if available.</p> <p>If a discovery_class was passed to init, this method will call its discover() method and return the results. If no discovery_class was provided (None), this returns an empty list and the setup flow will skip discovery.</p> <p>:return: List of discovered devices, or empty list if discovery not supported</p>"},{"location":"api/setup/#ucapi_framework.setup.BaseSetupFlow.prepare_input_from_discovery","title":"prepare_input_from_discovery  <code>async</code>","text":"<pre><code>prepare_input_from_discovery(\n    discovered: DiscoveredDevice,\n    additional_input: dict[str, Any],\n) -&gt; dict[str, Any]\n</code></pre> <p>Convert discovered device data to input_values format for query_device.</p> <p>This method transforms a discovered device into the same input_values format that manual entry produces. This allows query_device() to work uniformly for both discovery and manual entry paths.</p> <p>The returned dictionary should match the field names from your manual entry form, so query_device() can process both sources identically.</p> <p>DEFAULT IMPLEMENTATION: Returns a basic dictionary with common fields. Override this to customize the mapping for your integration.</p> <p>:param discovered: The discovered device selected by the user :param additional_input: Additional user input from the discovery screen                         (e.g., from get_additional_discovery_fields) :return: Dictionary of input values in the same format as manual entry</p> Example - Basic mapping <p>async def prepare_input_from_discovery(self, discovered, additional_input):     return {         \"identifier\": discovered.identifier,         \"address\": discovered.address,         \"name\": discovered.name,         \"port\": discovered.extra_data.get(\"port\", 8080),         # Include any additional fields from discovery screen         **additional_input     }</p> Example - With data transformation <p>async def prepare_input_from_discovery(self, discovered, additional_input):     # Extract specific data from extra_data     return {         \"identifier\": discovered.identifier,         \"address\": discovered.address,         \"name\": additional_input.get(\"name\", discovered.name),  # Allow override         \"model\": discovered.extra_data.get(\"model\"),         \"firmware\": discovered.extra_data.get(\"version\"),     }</p> Example - With filtering <p>async def prepare_input_from_discovery(self, discovered, additional_input):     # Only include relevant additional input fields     return {         \"identifier\": discovered.identifier,         \"address\": discovered.address,         \"name\": discovered.name,         # Only include specific additional fields, not \"choice\"         \"zone\": additional_input.get(\"zone\", 1),         \"volume_step\": additional_input.get(\"volume_step\", 5),     }</p>"},{"location":"api/setup/#ucapi_framework.setup.BaseSetupFlow.get_discovered_devices","title":"get_discovered_devices","text":"<pre><code>get_discovered_devices(\n    identifier: str | None = None,\n) -&gt; list[DiscoveredDevice] | DiscoveredDevice | None\n</code></pre> <p>Get discovered devices from the last discovery run.</p> <p>This is a convenience method that returns devices found by the framework's automatic discovery. Use this in your create_device_from_discovery() implementation to access device details.</p> <p>This is equivalent to accessing self.discovery.devices directly.</p> <p>:param identifier: Optional device identifier to look up a specific device.                   If provided, returns the matching DiscoveredDevice or None.                   If omitted, returns the full list of devices. :return: If identifier provided: DiscoveredDevice or None         If no identifier: List of all discovered devices (empty if none found)</p> Example - Get specific device <p>async def create_device_from_discovery(self, device_id, additional_data):     discovered = self.get_discovered_devices(device_id)     if not discovered:         return SetupError(error_type=IntegrationSetupError.NOT_FOUND)</p> <pre><code>return MyDeviceConfig(\n    identifier=discovered.identifier,\n    name=discovered.name,\n    address=discovered.address,\n    port=discovered.extra_data.get(\"port\", 80)\n)\n</code></pre> Example - Get all devices <p>async def create_device_from_discovery(self, device_id, additional_data):     for device in self.get_discovered_devices():         if device.identifier == device_id:             return MyDeviceConfig.from_discovered(device)     return SetupError(error_type=IntegrationSetupError.NOT_FOUND)</p>"},{"location":"api/setup/#ucapi_framework.setup.BaseSetupFlow.get_device_id","title":"get_device_id","text":"<pre><code>get_device_id(device_config: ConfigT) -&gt; str\n</code></pre> <p>Extract device ID from configuration.</p> <p>Default implementation: tries common attribute names (identifier, id, device_id). Override this if your config uses a different attribute name.</p> <p>:param device_config: Device configuration :return: Device identifier :raises AttributeError: If no valid ID attribute is found</p>"},{"location":"api/setup/#ucapi_framework.setup.BaseSetupFlow.get_device_name","title":"get_device_name","text":"<pre><code>get_device_name(device_config: ConfigT) -&gt; str\n</code></pre> <p>Extract device name from configuration.</p> <p>Default implementation: tries common attribute names (name, friendly_name, device_name). Override this if your config uses a different attribute name.</p> <p>:param device_config: Device configuration :return: Device name :raises AttributeError: If no valid name attribute is found</p>"},{"location":"api/setup/#ucapi_framework.setup.BaseSetupFlow.format_discovered_device_label","title":"format_discovered_device_label","text":"<pre><code>format_discovered_device_label(\n    device: DiscoveredDevice,\n) -&gt; str\n</code></pre> <p>Format how a discovered device appears in the dropdown list.</p> <p>Override this method to customize how devices are displayed to users during discovery. The default format shows the device name and address.</p> <p>:param device: The discovered device to format :return: Formatted label string</p> Example - Include model information <p>def format_discovered_device_label(self, device):     model = device.extra_data.get(\"model\", \"Unknown\")     return f\"{device.name} - {model} ({device.address})\"</p> Example - Show additional details <p>def format_discovered_device_label(self, device):     version = device.extra_data.get(\"version\", \"\")     return f\"{device.name} [{version}] at {device.address}\"</p>"},{"location":"api/setup/#ucapi_framework.setup.BaseSetupFlow.get_discovered_devices_screen","title":"get_discovered_devices_screen  <code>async</code>","text":"<pre><code>get_discovered_devices_screen(\n    devices: list[DiscoveredDevice],\n) -&gt; RequestUserInput\n</code></pre> <p>Build the discovered devices selection screen.</p> <p>Override this method to completely customize the discovery screen layout, such as adding additional fields, changing the title, or using a different input type.</p> <p>The default implementation creates a dropdown with all discovered devices (using format_discovered_device_label for labels), plus a \"Setup Manually\" option, and includes any additional fields from get_additional_discovery_fields().</p> <p>The selected device's identifier will be passed to create_device_from_discovery().</p> <p>:param devices: List of discovered devices :return: RequestUserInput screen to show to the user</p> Example - Custom screen with additional fields <p>async def get_discovered_devices_screen(self, devices):     dropdown_items = [         {             \"id\": d.identifier,             \"label\": {\"en\": self.format_discovered_device_label(d)}         }         for d in devices     ]     dropdown_items.append({\"id\": \"manual\", \"label\": {\"en\": \"Manual Setup\"}})</p> <pre><code>return RequestUserInput(\n    {\"en\": \"Select Your Device\"},\n    [\n        {\n            \"id\": \"choice\",\n            \"label\": {\"en\": \"Available Devices\"},\n            \"field\": {\"dropdown\": {\"value\": dropdown_items[0][\"id\"], \"items\": dropdown_items}}\n        },\n        {\n            \"id\": \"zone\",\n            \"label\": {\"en\": \"Default Zone\"},\n            \"field\": {\"number\": {\"value\": 1, \"min\": 1, \"max\": 10}}\n        }\n    ]\n)\n</code></pre>"},{"location":"api/setup/#ucapi_framework.setup.BaseSetupFlow.get_additional_discovery_fields","title":"get_additional_discovery_fields","text":"<pre><code>get_additional_discovery_fields() -&gt; list[dict]\n</code></pre> <p>Get additional fields to show during discovery.</p> <p>Override to add custom fields (e.g., volume step, zone selection).</p> <p>:return: List of field definitions</p>"},{"location":"api/setup/#ucapi_framework.setup.BaseSetupFlow.extract_additional_setup_data","title":"extract_additional_setup_data","text":"<pre><code>extract_additional_setup_data(\n    input_values: dict[str, Any],\n) -&gt; dict[str, Any]\n</code></pre> <p>Extract additional setup data from input values.</p> <p>Override to extract additional custom fields.</p> <p>:param input_values: User input values :return: Dictionary of additional data</p>"},{"location":"api/setup/#ucapi_framework.setup.BaseSetupFlow.get_pre_discovery_screen","title":"get_pre_discovery_screen  <code>async</code>","text":"<pre><code>get_pre_discovery_screen() -&gt; RequestUserInput | None\n</code></pre> <p>Request pre-discovery configuration screen(s).</p> <p>Override this method to show configuration screens BEFORE device discovery. This is useful for collecting credentials, API keys, server addresses, or other information needed to perform discovery.</p> <p>The collected data is stored in self._pre_discovery_data and can be accessed during discovery (in discover_devices()) or device creation.</p> <p>To show a pre-discovery screen: 1. Return a RequestUserInput with the fields you need 2. Handle the response in handle_pre_discovery_response() 3. Return another RequestUserInput to show more screens, or None to proceed</p> <p>:return: RequestUserInput to show a screen, or None to skip pre-discovery</p>"},{"location":"api/setup/#ucapi_framework.setup.BaseSetupFlow.handle_pre_discovery_response","title":"handle_pre_discovery_response  <code>async</code>","text":"<pre><code>handle_pre_discovery_response(\n    msg: UserDataResponse,\n) -&gt; SetupAction | None\n</code></pre> <p>Handle response from pre-discovery screens.</p> <p>Override this method to process responses from screens created by get_pre_discovery_screen(). The input values are automatically stored in self._pre_discovery_data before this method is called.</p> <p>You should: 1. Validate the input (optionally) 2. Either:    - Return another RequestUserInput for more pre-discovery screens, or    - Return None to proceed to device discovery</p> <p>If you return None, the base class will call discover_devices() where you can access self._pre_discovery_data to use the collected information.</p> <p>:param msg: User data response from pre-discovery screen :return: RequestUserInput for another screen, or None to proceed to discovery</p>"},{"location":"api/setup/#ucapi_framework.setup.BaseSetupFlow.get_additional_configuration_screen","title":"get_additional_configuration_screen  <code>async</code>","text":"<pre><code>get_additional_configuration_screen(\n    device_config: ConfigT, previous_input: dict[str, Any]\n) -&gt; RequestUserInput | None\n</code></pre> <p>Request additional configuration screens after device creation.</p> <p>Override this method to show additional setup screens that collect more information about the device. This is called after query_device (for both manual entry and discovery paths) but BEFORE the device is saved.</p> <p>AUTO-POPULATION: Any fields returned by this screen will automatically populate matching attributes on self._pending_device_config. You typically don't need to manually handle the response!</p> Example - Simple additional screen <p>async def get_additional_configuration_screen(self, device_config, previous_input):     return RequestUserInput(         {\"en\": \"Additional Settings\"},         [             {\"id\": \"token\", \"label\": {\"en\": \"API Token\"},              \"field\": {\"text\": {\"value\": \"\"}}},             {\"id\": \"zone\", \"label\": {\"en\": \"Zone\"},              \"field\": {\"number\": {\"value\": 1}}}         ]     )     # token and zone will auto-populate if device_config has those attributes!</p> Example - Conditional screen <p>async def get_additional_configuration_screen(self, device_config, previous_input):     if device_config.requires_auth:         return RequestUserInput(             {\"en\": \"Authentication\"},             [{\"id\": \"password\", \"label\": {\"en\": \"Password\"},               \"field\": {\"text\": {\"value\": \"\"}}}]         )     return None  # No additional screen needed</p> <p>:param device_config: The device configuration (also in self._pending_device_config) :param previous_input: Input values from the previous screen :return: RequestUserInput to show another screen, or None to complete setup</p>"},{"location":"api/setup/#ucapi_framework.setup.BaseSetupFlow.handle_additional_configuration_response","title":"handle_additional_configuration_response  <code>async</code>","text":"<pre><code>handle_additional_configuration_response(\n    msg: UserDataResponse,\n) -&gt; ConfigT | SetupAction | None\n</code></pre> <p>Handle response from additional configuration screens.</p> <p>Override this method to process responses from custom setup screens created by get_additional_configuration_screen().</p> <p>AUTO-POPULATION: The framework automatically populates self._pending_device_config from msg.input_values where field names match config attributes. In most cases, you don't need to override this method at all!</p> <p>Return one of: - None (recommended): Auto-populated fields are saved automatically - ConfigT (device config): Replace pending config and save this one - RequestUserInput: Show another configuration screen - SetupError: Abort setup with an error</p> <p>Example - No override needed (auto-population):     # If your screen has fields like \"token\" and \"zone\" that match     # attributes on your device config, they're automatically set!     # No need to override handle_additional_configuration_response at all.</p> Example - With validation <p>async def handle_additional_configuration_response(self, msg):     # Fields already auto-populated, just validate     if not self._pending_device_config.token:         return SetupError(error_type=IntegrationSetupError.AUTHORIZATION_ERROR)</p> <pre><code># Or add computed fields\nself._pending_device_config.full_url = (\n    f\"https://{self._pending_device_config.address}:8080\"\n)\nreturn None  # Save and complete\n</code></pre> Example - Show another screen <p>async def handle_additional_configuration_response(self, msg):     # Check if we need authentication     if self._pending_device_config.requires_auth:         return RequestUserInput(             {\"en\": \"Enter Password\"},             [{\"id\": \"password\", \"label\": {\"en\": \"Password\"},               \"field\": {\"text\": {\"value\": \"\"}}}]         )     return None</p> <p>Example - Replace entire config (advanced):     async def handle_additional_configuration_response(self, msg):         # Create completely new config (rarely needed)         return MyDeviceConfig(             identifier=self._pending_device_config.identifier,             name=self._pending_device_config.name,             address=self._pending_device_config.address,             token=msg.input_values[\"token\"],  # Manual access if needed         )</p> <p>:param msg: User data response from additional screen :return: Device config to save, SetupAction, or None to complete</p>"},{"location":"api/setup/#setupsteps","title":"SetupSteps","text":""},{"location":"api/setup/#ucapi_framework.setup.SetupSteps","title":"ucapi_framework.setup.SetupSteps","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enumeration of setup steps to keep track of user data responses.</p>"},{"location":"guide/configuration/","title":"Configuration Management","text":"<p>Configuration management in the framework is built around dataclasses and provides automatic JSON serialization, CRUD operations, and backup/restore functionality.</p>"},{"location":"guide/configuration/#defining-configuration","title":"Defining Configuration","text":"<p>Configuration is just a dataclass:</p> <pre><code>from dataclasses import dataclass\n\n@dataclass\nclass MyDeviceConfig:\n    \"\"\"Device configuration.\"\"\"\n    identifier: str\n    name: str\n    host: str\n    port: int = 8080\n    api_key: str = \"\"\n</code></pre> <p>The framework automatically handles:</p> <ul> <li>\u2705 JSON serialization/deserialization</li> <li>\u2705 Type validation</li> <li>\u2705 Default values</li> <li>\u2705 Nested dataclasses</li> </ul>"},{"location":"guide/configuration/#creating-a-config-manager","title":"Creating a Config Manager","text":"<pre><code>from ucapi_framework import BaseConfigManager\n\nconfig = BaseConfigManager[MyDeviceConfig](\n    data_path=\"./config\",\n    add_handler=driver.on_device_added,\n    remove_handler=driver.on_device_removed,\n)\n</code></pre>"},{"location":"guide/configuration/#crud-operations","title":"CRUD Operations","text":""},{"location":"guide/configuration/#add-or-update","title":"Add or Update","text":"<pre><code>device_config = MyDeviceConfig(\n    identifier=\"device_1\",\n    name=\"My Device\",\n    host=\"192.168.1.100\",\n)\n\nconfig.add_or_update(device_config)\n</code></pre>"},{"location":"guide/configuration/#get","title":"Get","text":"<pre><code>device = config.get(\"device_1\")\nif device:\n    print(f\"Found: {device.name}\")\n</code></pre>"},{"location":"guide/configuration/#remove","title":"Remove","text":"<pre><code>if config.remove(\"device_1\"):\n    print(\"Device removed\")\n</code></pre>"},{"location":"guide/configuration/#iterate-all","title":"Iterate All","text":"<pre><code>for device in config.all():\n    print(f\"Device: {device.name} at {device.host}\")\n</code></pre>"},{"location":"guide/configuration/#check-existence","title":"Check Existence","text":"<pre><code>if config.contains(\"device_1\"):\n    print(\"Device exists\")\n</code></pre>"},{"location":"guide/configuration/#clear-all","title":"Clear All","text":"<pre><code>config.clear()  # Removes all devices\n</code></pre>"},{"location":"guide/configuration/#persistence","title":"Persistence","text":"<p>Configuration is automatically persisted to disk:</p> <ul> <li>Auto-save on add/update/remove</li> <li>Auto-load on initialization</li> <li>Atomic writes prevent corruption</li> <li>Backup on changes (optional)</li> </ul>"},{"location":"guide/configuration/#backup-restore","title":"Backup &amp; Restore","text":""},{"location":"guide/configuration/#export-configuration","title":"Export Configuration","text":"<pre><code>json_backup = config.get_backup_json()\n# Save to file or send to user\n</code></pre>"},{"location":"guide/configuration/#import-configuration","title":"Import Configuration","text":"<pre><code>success = config.restore_from_backup_json(json_backup)\nif success:\n    print(\"Configuration restored\")\n</code></pre>"},{"location":"guide/configuration/#configuration-callbacks","title":"Configuration Callbacks","text":"<p>The config manager can notify your driver when devices are added or removed:</p> <pre><code>def on_device_added(device_config: MyDeviceConfig) -&gt; None:\n    \"\"\"Called when device is added.\"\"\"\n    print(f\"Device added: {device_config.name}\")\n    driver.add_configured_device(device_config)\n\ndef on_device_removed(device_config: MyDeviceConfig | None) -&gt; None:\n    \"\"\"Called when device is removed.\"\"\"\n    if device_config is None:\n        print(\"All devices removed\")\n        driver.clear_devices()\n    else:\n        print(f\"Device removed: {device_config.name}\")\n        driver.remove_device(driver.get_device_id(device_config))\n\nconfig = BaseConfigManager[MyDeviceConfig](\n    data_path=\"./config\",\n    add_handler=on_device_added,\n    remove_handler=on_device_removed,\n)\n</code></pre>"},{"location":"guide/configuration/#dynamic-configuration-updates","title":"Dynamic Configuration Updates","text":"<p>Devices can update their own configuration at runtime:</p> <pre><code>class MyDevice(StatelessHTTPDevice):\n    async def authenticate(self) -&gt; None:\n        \"\"\"Authenticate and update token.\"\"\"\n        new_token = await self._get_auth_token()\n\n        # Update config with new token\n        self.update_config(api_token=new_token)\n        # Changes are automatically persisted!\n</code></pre>"},{"location":"guide/configuration/#type-safety","title":"Type Safety","text":"<p>The config manager is fully typed:</p> <pre><code>config = BaseConfigManager[MyDeviceConfig](...)\n\n# IDE knows this returns MyDeviceConfig | None\ndevice = config.get(\"device_1\")\n\n# Type checking works\nif device:\n    print(device.host)  # \u2705 IDE autocomplete works\n    print(device.invalid)  # \u274c Type error\n</code></pre>"},{"location":"guide/configuration/#migration-support","title":"Migration Support","text":"<p>The framework supports configuration migration:</p> <pre><code>class MyConfigManager(BaseConfigManager[MyDeviceConfig]):\n    def migration_required(self) -&gt; bool:\n        \"\"\"Check if migration is needed.\"\"\"\n        # Check for old config format\n        return os.path.exists(\"old_config.json\")\n\n    async def migrate(self) -&gt; bool:\n        \"\"\"Migrate from old format.\"\"\"\n        # Load old config\n        with open(\"old_config.json\") as f:\n            old_data = json.load(f)\n\n        # Convert to new format\n        for item in old_data:\n            new_config = MyDeviceConfig(\n                identifier=item[\"id\"],\n                name=item[\"device_name\"],\n                host=item[\"ip\"],\n            )\n            self.add_or_update(new_config)\n\n        # Clean up old file\n        os.remove(\"old_config.json\")\n        return True\n</code></pre>"},{"location":"guide/configuration/#best-practices","title":"Best Practices","text":"<ol> <li>Use dataclasses - They're simple, type-safe, and work great with the framework</li> <li>Provide defaults - Use default values for optional fields</li> <li>Keep it flat - Avoid deep nesting when possible</li> <li>Use type hints - Full type safety means fewer bugs</li> <li>Validate on load - Use <code>__post_init__</code> for validation if needed</li> </ol> <pre><code>@dataclass\nclass MyDeviceConfig:\n    identifier: str\n    name: str\n    host: str\n    port: int = 8080\n\n    def __post_init__(self):\n        \"\"\"Validate configuration.\"\"\"\n        if not 1 &lt;= self.port &lt;= 65535:\n            raise ValueError(f\"Invalid port: {self.port}\")\n\n        # Normalize host\n        self.host = self.host.strip()\n</code></pre> <p>See the API Reference for complete documentation.</p>"},{"location":"guide/device-patterns/","title":"Device Patterns","text":"<p>The framework provides four base device classes for different connection patterns. Choose the one that matches your device's communication method.</p>"},{"location":"guide/device-patterns/#statelesshttpdevice","title":"StatelessHTTPDevice","text":"<p>For devices with REST APIs where each request creates a new HTTP session.</p> <p>Good for: REST APIs, simple HTTP devices</p> <p>You implement:</p> <ul> <li><code>verify_connection()</code> - Test device is reachable</li> <li>Property accessors (<code>identifier</code>, <code>name</code>, <code>address</code>, <code>log_id</code>)</li> </ul> <p>Framework handles:</p> <ul> <li>HTTP session management</li> <li>Connection verification</li> <li>Error handling</li> </ul>"},{"location":"guide/device-patterns/#example","title":"Example","text":"<pre><code>from ucapi_framework import StatelessHTTPDevice\nimport aiohttp\n\nclass MyRESTDevice(StatelessHTTPDevice):\n    @property\n    def identifier(self) -&gt; str:\n        return self._device_config.identifier\n\n    @property\n    def name(self) -&gt; str:\n        return self._device_config.name\n\n    @property\n    def address(self) -&gt; str:\n        return self._device_config.host\n\n    @property\n    def log_id(self) -&gt; str:\n        return f\"Device[{self.identifier}]\"\n\n    async def verify_connection(self) -&gt; None:\n        \"\"\"Verify device is reachable.\"\"\"\n        url = f\"http://{self.address}/api/status\"\n        async with aiohttp.ClientSession() as session:\n            async with session.get(url) as response:\n                response.raise_for_status()\n\n    async def send_command(self, command: str) -&gt; None:\n        \"\"\"Send command to device.\"\"\"\n        url = f\"http://{self.address}/api/command\"\n        async with aiohttp.ClientSession() as session:\n            async with session.post(url, json={\"command\": command}) as response:\n                response.raise_for_status()\n</code></pre>"},{"location":"guide/device-patterns/#pollingdevice","title":"PollingDevice","text":"<p>For devices that need periodic state checks.</p> <p>Good for: Devices without push notifications, devices with changing state</p> <p>You implement:</p> <ul> <li><code>establish_connection()</code> - Initial connection setup</li> <li><code>poll_device()</code> - Periodic state check (emits UPDATE events)</li> <li>Property accessors</li> </ul> <p>Framework handles:</p> <ul> <li>Polling loop with configurable interval</li> <li>Automatic reconnection on errors</li> <li>Task management and cleanup</li> </ul>"},{"location":"guide/device-patterns/#example_1","title":"Example","text":"<pre><code>from ucapi_framework import PollingDevice, DeviceEvents\nimport aiohttp\n\nclass MyPollingDevice(PollingDevice):\n    def __init__(self, device_config, config_manager=None):\n        super().__init__(\n            device_config,\n            poll_interval=30,  # Poll every 30 seconds\n            config_manager=config_manager\n        )\n        self._session = None\n\n    @property\n    def identifier(self) -&gt; str:\n        return self._device_config.identifier\n\n    @property\n    def name(self) -&gt; str:\n        return self._device_config.name\n\n    @property\n    def address(self) -&gt; str:\n        return self._device_config.host\n\n    @property\n    def log_id(self) -&gt; str:\n        return f\"Device[{self.identifier}]\"\n\n    async def establish_connection(self) -&gt; None:\n        \"\"\"Initial connection.\"\"\"\n        self._session = aiohttp.ClientSession()\n\n    async def poll_device(self) -&gt; None:\n        \"\"\"Poll device state.\"\"\"\n        url = f\"http://{self.address}/api/state\"\n        async with self._session.get(url) as response:\n            state = await response.json()\n            self._state = state[\"power\"]\n\n            # Emit update event\n            self.events.emit(\n                DeviceEvents.UPDATE,\n                self.identifier,\n                {\"state\": state[\"power\"], \"volume\": state[\"volume\"]}\n            )\n</code></pre>"},{"location":"guide/device-patterns/#websocketdevice","title":"WebSocketDevice","text":"<p>For devices with WebSocket APIs providing real-time updates.</p> <p>Good for: Devices with WebSocket APIs, real-time updates</p> <p>You implement:</p> <ul> <li><code>create_websocket()</code> - Establish WebSocket connection</li> <li><code>close_websocket()</code> - Close WebSocket connection</li> <li><code>receive_message()</code> - Receive message from WebSocket</li> <li><code>handle_message()</code> - Process received message</li> <li>Property accessors</li> </ul> <p>Framework handles:</p> <ul> <li>WebSocket lifecycle (connect, reconnect, disconnect)</li> <li>Exponential backoff on connection failures</li> <li>Ping/pong keepalive</li> <li>Message loop and error handling</li> </ul>"},{"location":"guide/device-patterns/#example_2","title":"Example","text":"<pre><code>from ucapi_framework import WebSocketDevice, DeviceEvents\nimport websockets\n\nclass MyWebSocketDevice(WebSocketDevice):\n    def __init__(self, device_config, config_manager=None):\n        super().__init__(\n            device_config,\n            reconnect=True,\n            ping_interval=30,  # Ping every 30 seconds\n            config_manager=config_manager\n        )\n\n    @property\n    def identifier(self) -&gt; str:\n        return self._device_config.identifier\n\n    @property\n    def name(self) -&gt; str:\n        return self._device_config.name\n\n    @property\n    def address(self) -&gt; str:\n        return self._device_config.host\n\n    @property\n    def log_id(self) -&gt; str:\n        return f\"Device[{self.identifier}]\"\n\n    async def create_websocket(self):\n        \"\"\"Create WebSocket connection.\"\"\"\n        uri = f\"ws://{self.address}/ws\"\n        return await websockets.connect(uri)\n\n    async def close_websocket(self) -&gt; None:\n        \"\"\"Close WebSocket connection.\"\"\"\n        if self._ws:\n            await self._ws.close()\n\n    async def receive_message(self):\n        \"\"\"Receive message from WebSocket.\"\"\"\n        return await self._ws.recv()\n\n    async def handle_message(self, message: str) -&gt; None:\n        \"\"\"Process received message.\"\"\"\n        import json\n        data = json.loads(message)\n\n        if data[\"type\"] == \"state_update\":\n            self._state = data[\"state\"]\n            self.events.emit(\n                DeviceEvents.UPDATE,\n                self.identifier,\n                {\"state\": data[\"state\"]}\n            )\n</code></pre>"},{"location":"guide/device-patterns/#websocketpollingdevice","title":"WebSocketPollingDevice","text":"<p>Hybrid device combining WebSocket for real-time updates with polling as a fallback.</p> <p>Good for: Smart TVs, media players with WebSocket that may disconnect</p> <p>You implement: Same as WebSocketDevice + PollingDevice</p> <p>Framework handles:</p> <ul> <li>Runs both WebSocket and polling concurrently</li> <li>Continues polling if WebSocket fails</li> <li>Graceful degradation</li> </ul>"},{"location":"guide/device-patterns/#example_3","title":"Example","text":"<pre><code>from ucapi_framework import WebSocketPollingDevice\n\nclass MyHybridDevice(WebSocketPollingDevice):\n    def __init__(self, device_config, config_manager=None):\n        super().__init__(\n            device_config,\n            poll_interval=30,\n            ping_interval=30,\n            keep_polling_on_disconnect=True,\n            config_manager=config_manager\n        )\n\n    # Implement WebSocket methods\n    async def create_websocket(self): ...\n    async def close_websocket(self): ...\n    async def receive_message(self): ...\n    async def handle_message(self, message): ...\n\n    # Implement Polling methods\n    async def establish_connection(self): ...\n    async def poll_device(self): ...\n</code></pre>"},{"location":"guide/device-patterns/#persistentconnectiondevice","title":"PersistentConnectionDevice","text":"<p>For devices with persistent TCP connections or custom protocols.</p> <p>Good for: Proprietary protocols, TCP connections, persistent sessions</p> <p>You implement:</p> <ul> <li><code>establish_connection()</code> - Create persistent connection</li> <li><code>close_connection()</code> - Close connection</li> <li><code>maintain_connection()</code> - Keep connection alive (blocking)</li> <li>Property accessors</li> </ul> <p>Framework handles:</p> <ul> <li>Connection loop with automatic reconnection</li> <li>Exponential backoff on failures</li> <li>Task management</li> </ul>"},{"location":"guide/device-patterns/#example_4","title":"Example","text":"<pre><code>from ucapi_framework import PersistentConnectionDevice, DeviceEvents\n\nclass MyTCPDevice(PersistentConnectionDevice):\n    @property\n    def identifier(self) -&gt; str:\n        return self._device_config.identifier\n\n    @property\n    def name(self) -&gt; str:\n        return self._device_config.name\n\n    @property\n    def address(self) -&gt; str:\n        return self._device_config.host\n\n    @property\n    def log_id(self) -&gt; str:\n        return f\"Device[{self.identifier}]\"\n\n    async def establish_connection(self):\n        \"\"\"Establish TCP connection.\"\"\"\n        reader, writer = await asyncio.open_connection(\n            self.address, 8080\n        )\n        return {\"reader\": reader, \"writer\": writer}\n\n    async def close_connection(self) -&gt; None:\n        \"\"\"Close TCP connection.\"\"\"\n        if self._connection:\n            self._connection[\"writer\"].close()\n            await self._connection[\"writer\"].wait_closed()\n\n    async def maintain_connection(self) -&gt; None:\n        \"\"\"Maintain connection and process messages.\"\"\"\n        reader = self._connection[\"reader\"]\n\n        while True:\n            data = await reader.readline()\n            if not data:\n                break  # Connection closed\n\n            # Process message\n            message = data.decode().strip()\n            self.events.emit(\n                DeviceEvents.UPDATE,\n                self.identifier,\n                {\"message\": message}\n            )\n</code></pre>"},{"location":"guide/device-patterns/#externalclientdevice","title":"ExternalClientDevice","text":"<p>For devices using external client libraries that manage their own connections.</p> <p>Good for: Z-Wave JS, Home Assistant WebSocket, MQTT clients, third-party APIs</p> <p>You implement:</p> <ul> <li><code>create_client()</code> - Create the external client instance</li> <li><code>connect_client()</code> - Connect and set up event handlers</li> <li><code>disconnect_client()</code> - Disconnect and remove event handlers</li> <li><code>check_client_connected()</code> - Query actual client connection state</li> <li>Property accessors</li> </ul> <p>Framework handles:</p> <ul> <li>Watchdog polling to detect silent disconnections</li> <li>Automatic reconnection with configurable retries</li> <li>Early exit if client is already connected</li> <li>Task management and cleanup</li> </ul>"},{"location":"guide/device-patterns/#example_5","title":"Example","text":"<pre><code>from ucapi_framework import ExternalClientDevice, DeviceEvents\n\nclass MyExternalDevice(ExternalClientDevice):\n    def __init__(self, device_config, config_manager=None):\n        super().__init__(\n            device_config,\n            enable_watchdog=True,      # Monitor connection state\n            watchdog_interval=30,       # Check every 30 seconds\n            reconnect_delay=5,          # Wait 5s between reconnect attempts\n            max_reconnect_attempts=3,   # Give up after 3 failures (0 = infinite)\n            config_manager=config_manager\n        )\n\n    @property\n    def identifier(self) -&gt; str:\n        return self._device_config.identifier\n\n    @property\n    def name(self) -&gt; str:\n        return self._device_config.name\n\n    @property\n    def address(self) -&gt; str:\n        return self._device_config.host\n\n    @property\n    def log_id(self) -&gt; str:\n        return f\"Device[{self.identifier}]\"\n\n    async def create_client(self):\n        \"\"\"Create the external client instance.\"\"\"\n        from some_library import Client\n        return Client(self.address)\n\n    async def connect_client(self) -&gt; None:\n        \"\"\"Connect the client and set up event handlers.\"\"\"\n        await self._client.connect()\n        self._client.on(\"state_changed\", self._on_state_changed)\n\n    async def disconnect_client(self) -&gt; None:\n        \"\"\"Disconnect and clean up.\"\"\"\n        self._client.off(\"state_changed\", self._on_state_changed)\n        await self._client.disconnect()\n\n    def check_client_connected(self) -&gt; bool:\n        \"\"\"Check actual client connection state.\"\"\"\n        return self._client is not None and self._client.connected\n\n    def _on_state_changed(self, state):\n        \"\"\"Handle state changes from the client.\"\"\"\n        self.events.emit(\n            DeviceEvents.UPDATE,\n            self.identifier,\n            {\"state\": state}\n        )\n</code></pre>"},{"location":"guide/device-patterns/#choosing-a-pattern","title":"Choosing a Pattern","text":"Pattern Use Case Complexity StatelessHTTPDevice REST APIs, no real-time updates \u2b50 Simple PollingDevice Need periodic state checks \u2b50\u2b50 Moderate WebSocketDevice WebSocket APIs, real-time \u2b50\u2b50\u2b50 Complex WebSocketPollingDevice Hybrid with fallback \u2b50\u2b50\u2b50\u2b50 Advanced ExternalClientDevice Third-party client libraries \u2b50\u2b50\u2b50 Moderate PersistentConnectionDevice Custom protocols, TCP \u2b50\u2b50\u2b50\u2b50 Advanced <p>See the API Reference for complete documentation.</p>"},{"location":"guide/discovery/","title":"Discovery","text":"<p>The framework provides discovery implementations for common network protocols, making it easy to find devices automatically.</p>"},{"location":"guide/discovery/#discovery-classes","title":"Discovery Classes","text":"Class Protocol Use Case Package SSDPDiscovery UPnP/SSDP Smart TVs, media renderers <code>ssdpy</code> SDDPDiscovery SDDP Samsung TVs <code>sddp-discovery-protocol</code> MDNSDiscovery mDNS/Bonjour Apple devices, Chromecast <code>zeroconf</code> NetworkScanDiscovery TCP/IP scan Active probing Built-in BaseDiscovery Custom Library-specific discovery Built-in"},{"location":"guide/discovery/#basic-discovery","title":"Basic Discovery","text":"<p>All discovery classes return <code>DiscoveredDevice</code> objects:</p> <pre><code>@dataclass\nclass DiscoveredDevice:\n    identifier: str       # Unique ID (MAC, serial, etc.)\n    name: str            # Human-readable name\n    address: str         # IP address or connection string\n    extra_data: dict | None  # Protocol-specific data\n</code></pre>"},{"location":"guide/discovery/#ssdp-discovery","title":"SSDP Discovery","text":"<p>For UPnP/SSDP devices (media renderers, smart TVs):</p> <pre><code>from ucapi_framework.discovery import SSDPDiscovery, DiscoveredDevice\n\nclass MyS SDPDiscovery(SSDPDiscovery):\n    def __init__(self):\n        super().__init__(\n            search_target=\"urn:schemas-upnp-org:device:MediaRenderer:1\",\n            timeout=5\n        )\n\n    def parse_ssdp_device(self, raw_device: dict) -&gt; DiscoveredDevice | None:\n        \"\"\"Convert SSDP response to DiscoveredDevice.\"\"\"\n        try:\n            # Extract location URL\n            location = raw_device.get(\"location\", \"\")\n            if not location:\n                return None\n\n            # Parse IP from location\n            from urllib.parse import urlparse\n            parsed = urlparse(location)\n            host = parsed.hostname\n\n            return DiscoveredDevice(\n                identifier=raw_device.get(\"usn\", \"\"),\n                name=raw_device.get(\"server\", \"Unknown Device\"),\n                address=host,\n                extra_data={\"location\": location}\n            )\n        except Exception:\n            return None\n\n# Use in setup flow\ndiscovery = MySSDPDiscovery()\ndevices = await discovery.discover()\n</code></pre>"},{"location":"guide/discovery/#sddp-discovery","title":"SDDP Discovery","text":"<p>For SDDP devices (Samsung TVs):</p> <pre><code>from ucapi_framework.discovery import SDDPDiscovery, DiscoveredDevice\n\nclass MySDDPDiscovery(SDDPDiscovery):\n    def __init__(self):\n        super().__init__(\n            search_pattern=b\"NOTIFY * HTTP/1.1\",\n            timeout=5\n        )\n\n    def parse_sddp_response(\n        self, data: bytes, addr: tuple[str, int]\n    ) -&gt; DiscoveredDevice | None:\n        \"\"\"Parse SDDP response.\"\"\"\n        try:\n            message = data.decode('utf-8')\n\n            # Parse headers\n            lines = message.split('\\r\\n')\n            headers = {}\n            for line in lines[1:]:\n                if ':' in line:\n                    key, value = line.split(':', 1)\n                    headers[key.strip().upper()] = value.strip()\n\n            return DiscoveredDevice(\n                identifier=headers.get('USN', ''),\n                name=headers.get('SERVER', 'Samsung TV'),\n                address=addr[0],\n                extra_data=headers\n            )\n        except Exception:\n            return None\n</code></pre>"},{"location":"guide/discovery/#mdns-discovery","title":"mDNS Discovery","text":"<p>For mDNS/Bonjour devices (Chromecast, Apple TV):</p> <pre><code>from ucapi_framework.discovery import MDNSDiscovery, DiscoveredDevice\nfrom zeroconf import ServiceInfo\n\nclass MyMDNSDiscovery(MDNSDiscovery):\n    def __init__(self):\n        super().__init__(\n            service_type=\"_googlecast._tcp.local.\",\n            timeout=5\n        )\n\n    def parse_mdns_service(\n        self, service_info: ServiceInfo\n    ) -&gt; DiscoveredDevice | None:\n        \"\"\"Parse mDNS service info.\"\"\"\n        if not service_info.addresses:\n            return None\n\n        # Get first IPv4 address\n        import socket\n        address = socket.inet_ntoa(service_info.addresses[0])\n\n        # Extract name and properties\n        name = service_info.name.replace(f\".{self.service_type}\", \"\")\n        properties = {\n            k.decode(): v.decode() if isinstance(v, bytes) else v\n            for k, v in service_info.properties.items()\n        }\n\n        return DiscoveredDevice(\n            identifier=service_info.name,\n            name=name,\n            address=address,\n            extra_data=properties\n        )\n</code></pre>"},{"location":"guide/discovery/#network-scan-discovery","title":"Network Scan Discovery","text":"<p>For devices that don't support standard discovery:</p> <pre><code>from ucapi_framework.discovery import NetworkScanDiscovery, DiscoveredDevice\n\nclass MyNetworkScanDiscovery(NetworkScanDiscovery):\n    def __init__(self):\n        super().__init__(\n            ip_range=\"192.168.1.0/24\",\n            ports=[8080, 9000],\n            timeout=10\n        )\n\n    async def probe_device(\n        self, ip: str, port: int\n    ) -&gt; DiscoveredDevice | None:\n        \"\"\"Probe IP:port for device.\"\"\"\n        try:\n            # Try to connect and identify device\n            url = f\"http://{ip}:{port}/api/info\"\n            async with aiohttp.ClientSession() as session:\n                async with session.get(url, timeout=2) as response:\n                    if response.status == 200:\n                        data = await response.json()\n                        return DiscoveredDevice(\n                            identifier=data[\"id\"],\n                            name=data[\"name\"],\n                            address=ip,\n                            extra_data={\"port\": port}\n                        )\n        except Exception:\n            pass\n\n        return None\n</code></pre>"},{"location":"guide/discovery/#custom-discovery","title":"Custom Discovery","text":"<p>For devices with library-specific discovery:</p> <pre><code>from ucapi_framework import BaseDiscovery, DiscoveredDevice\n\nclass MyCustomDiscovery(BaseDiscovery):\n    async def discover(self) -&gt; list[DiscoveredDevice]:\n        \"\"\"Call library discovery and convert results.\"\"\"\n        import my_device_library\n\n        # Call library's discovery\n        raw_devices = await my_device_library.discover()\n\n        # Convert to DiscoveredDevice\n        self._discovered_devices.clear()\n        for raw in raw_devices:\n            device = DiscoveredDevice(\n                identifier=raw.serial_number,\n                name=raw.friendly_name,\n                address=raw.ip_address,\n                extra_data={\"model\": raw.model}\n            )\n            self._discovered_devices.append(device)\n\n        return self._discovered_devices\n</code></pre>"},{"location":"guide/discovery/#using-discovery-in-setup-flow","title":"Using Discovery in Setup Flow","text":"<p>Integrate discovery into your setup flow:</p> <pre><code>from ucapi_framework import BaseSetupFlow\n\nclass MySetupFlow(BaseSetupFlow[MyDeviceConfig]):\n    async def discover_devices(self) -&gt; list[DiscoveredDevice]:\n        \"\"\"Run discovery.\"\"\"\n        if self._discovery:\n            return await self._discovery.discover()\n        return []\n\n    async def prepare_input_from_discovery(\n        self, device: DiscoveredDevice\n    ) -&gt; dict:\n        \"\"\"Convert discovered device to input values.\"\"\"\n        return {\n            \"identifier\": device.identifier,\n            \"name\": device.name,\n            \"host\": device.address,\n        }\n\n# Create setup flow with discovery\ndiscovery = MySSDPDiscovery()\nsetup_flow = MySetupFlow(config_manager, discovery=discovery)\n</code></pre>"},{"location":"guide/discovery/#no-discovery","title":"No Discovery","text":"<p>If your integration doesn't support discovery, simply pass <code>None</code>:</p> <pre><code>setup_flow = MySetupFlow(config_manager, discovery=None)\n</code></pre> <p>The setup flow will skip discovery and go straight to manual entry.</p>"},{"location":"guide/discovery/#best-practices","title":"Best Practices","text":"<ol> <li>Timeout appropriately - Balance thoroughness with user experience</li> <li>Filter results - Return only compatible devices</li> <li>Handle errors gracefully - Discovery can fail for many reasons</li> <li>Provide fallback - Always support manual entry</li> <li>Cache results - Don't re-discover on every attempt</li> </ol> <pre><code>class MySSDPDiscovery(SSDPDiscovery):\n    def __init__(self):\n        super().__init__(\n            search_target=\"urn:my-device:1\",\n            timeout=5,\n            device_filter=self._is_compatible  # Filter function\n        )\n\n    def _is_compatible(self, raw_device: dict) -&gt; bool:\n        \"\"\"Check if device is compatible.\"\"\"\n        model = raw_device.get(\"server\", \"\")\n        return \"MyDevice\" in model\n</code></pre> <p>See the API Reference for complete documentation.</p>"},{"location":"guide/driver/","title":"Driver Integration","text":"<p>The driver is the central coordinator of your integration, managing device lifecycle, entity registration, and Remote events.</p>"},{"location":"guide/driver/#core-responsibilities","title":"Core Responsibilities","text":"<p>The <code>BaseIntegrationDriver</code> handles:</p> <ul> <li>\u2705 Remote Two event handling (connect, disconnect, standby)</li> <li>\u2705 Entity subscription management</li> <li>\u2705 Device lifecycle (add, remove, connect, disconnect)</li> <li>\u2705 State propagation from devices to entities</li> <li>\u2705 Event routing and coordination</li> </ul>"},{"location":"guide/driver/#default-implementations","title":"Default Implementations","text":"<p>The driver provides sensible defaults for common patterns. You typically don't need to override these methods unless you have specific requirements:</p>"},{"location":"guide/driver/#1-create_entities-has-default","title":"1. create_entities() \u2705 Has Default","text":"<p>Default behavior: Creates one instance per entity class passed to <code>__init__</code>, calling: <code>entity_class(device_config, device)</code></p> <pre><code># Works automatically for standard entity creation\ndriver = MyIntegrationDriver(\n    device_class=MyDevice,\n    entity_classes=[MyMediaPlayer, MyRemote]\n)\n# Framework automatically calls: MyMediaPlayer(device_config, device), MyRemote(device_config, device)\n</code></pre> <p>Override when you need:</p> <ul> <li>Variable entity counts (e.g., multi-zone receivers)</li> <li>Hub-based discovery</li> <li>Conditional entity creation</li> <li>Custom parameters beyond <code>(device_config, device)</code></li> </ul>"},{"location":"guide/driver/#example-multi-zone-receiver","title":"Example: Multi-Zone Receiver","text":"<pre><code>class AnthemDriver(BaseIntegrationDriver):\n    def create_entities(self, device_config: AnthemConfig, device: AnthemDevice) -&gt; list[Entity]:\n        \"\"\"Create one media player per configured zone.\"\"\"\n        entities = []\n\n        for zone in device_config.zones:\n            entity = AnthemMediaPlayer(\n                entity_id=f\"media_player.{device_config.id}_zone_{zone.id}\",\n                device=device,\n                device_config=device_config,\n                zone_config=zone,  # Custom parameter!\n            )\n            entities.append(entity)\n\n        return entities\n</code></pre> <p>Your entity class accepts the custom parameters:</p> <pre><code>class AnthemMediaPlayer(MediaPlayer):\n    def __init__(\n        self,\n        entity_id: str,\n        device: AnthemDevice,\n        device_config: AnthemConfig,\n        zone_config: ZoneConfig,  # Custom!\n    ):\n        self._device = device\n        self._zone = zone_config\n\n        super().__init__(\n            entity_id,\n            f\"{device_config.name} {zone_config.name}\",\n            features=[...],\n            attributes={...},\n        )\n</code></pre>"},{"location":"guide/driver/#example-hub-based-discovery","title":"Example: Hub-Based Discovery","text":"<pre><code>class LutronDriver(BaseIntegrationDriver):\n    def create_entities(self, device_config: LutronConfig, device: LutronHub) -&gt; list[Entity]:\n        \"\"\"Discover and create entities from hub.\"\"\"\n        entities = []\n\n        # Query hub for available devices\n        for hub_device in device.discover_devices():\n            if hub_device.type == \"light\":\n                entity = LutronLight(\n                    entity_id=f\"light.{device_config.id}_{hub_device.id}\",\n                    device=device,\n                    device_config=device_config,\n                    hub_device=hub_device,  # Custom parameter!\n                )\n            elif hub_device.type == \"cover\":\n                entity = LutronCover(\n                    entity_id=f\"cover.{device_config.id}_{hub_device.id}\",\n                    device=device,\n                    device_config=device_config,\n                    hub_device=hub_device,  # Custom parameter!\n                )\n            entities.append(entity)\n\n        return entities\n</code></pre>"},{"location":"guide/driver/#example-conditional-creation","title":"Example: Conditional Creation","text":"<pre><code>class YamahaDriver(BaseIntegrationDriver):\n    def create_entities(self, device_config, device) -&gt; list[Entity]:\n        \"\"\"Create entities based on device capabilities.\"\"\"\n        entities = []\n\n        if device.supports_playback:\n            entities.append(YamahaMediaPlayer(device_config, device))\n\n        if device.supports_remote:\n            entities.append(YamahaRemote(device_config, device))\n\n        return entities\n</code></pre>"},{"location":"guide/driver/#2-map_device_state-has-default","title":"2. map_device_state() \u2705 Has Default","text":"<p>Default behavior: Converts common state strings to <code>media_player.States</code>:</p> <ul> <li><code>\"ON\"</code>, <code>\"MENU\"</code>, <code>\"IDLE\"</code> \u2192 <code>States.ON</code></li> <li><code>\"OFF\"</code>, <code>\"POWER_OFF\"</code> \u2192 <code>States.OFF</code></li> <li><code>\"PLAYING\"</code>, <code>\"PLAY\"</code> \u2192 <code>States.PLAYING</code></li> <li><code>\"PAUSED\"</code> \u2192 <code>States.PAUSED</code></li> <li><code>\"STANDBY\"</code> \u2192 <code>States.STANDBY</code></li> <li><code>\"BUFFERING\"</code> \u2192 <code>States.BUFFERING</code></li> <li>Everything else \u2192 <code>States.UNKNOWN</code></li> </ul> <pre><code># Works automatically for common device states\ndevice.state = \"PLAYING\"  # Maps to media_player.States.PLAYING\n</code></pre> <p>Override only if you have custom state enums:</p> <pre><code>def map_device_state(self, device_state: Any) -&gt; media_player.States:\n    \"\"\"Map custom device state enum.\"\"\"\n    if isinstance(device_state, MyDeviceState):\n        match device_state:\n            case MyDeviceState.POWERED_ON:\n                return media_player.States.ON\n            case MyDeviceState.POWERED_OFF:\n                return media_player.States.OFF\n            case MyDeviceState.PLAYING:\n                return media_player.States.PLAYING\n            case _:\n                return media_player.States.UNKNOWN\n\n    # Fallback to default for string states\n    return super().map_device_state(device_state)\n</code></pre>"},{"location":"guide/driver/#3-device_from_entity_id-has-default","title":"3. device_from_entity_id() \u2705 Has Default","text":"<p>Default behavior: Parses standard entity ID format <code>\"entity_type.device_id\"</code> or <code>\"entity_type.device_id.entity_id\"</code>.</p> <pre><code># Works automatically with create_entity_id()\nentity_id = \"media_player.receiver_123\"\ndevice_id = driver.device_from_entity_id(entity_id)  # Returns \"receiver_123\"\n</code></pre> <p>Override only if you use a custom entity ID format:</p> <pre><code>def create_entities(\n    self, device_config: MyDeviceConfig, device: MyDevice\n) -&gt; list[Entity]:\n    \"\"\"Custom entity ID format.\"\"\"\n    # Entity ID IS the device ID (custom format)\n    return [MyMediaPlayer(device_config.identifier, ...)]\n\ndef device_from_entity_id(self, entity_id: str) -&gt; str | None:\n    \"\"\"Parse custom entity ID format.\"\"\"\n    # For this custom format, entity_id IS the device_id\n    return entity_id\n</code></pre> <p>Important</p> <p>If you override <code>create_entities()</code> with a custom entity ID format, you must also override <code>device_from_entity_id()</code> to match. The framework will raise an error if you forget.</p>"},{"location":"guide/driver/#5-entity_type_from_entity_id-has-default","title":"5. entity_type_from_entity_id() \u2705 Has Default","text":"<p>Default behavior: Extracts entity type from standard format <code>\"entity_type.device_id\"</code>.</p> <pre><code>entity_id = \"media_player.receiver_123\"\nentity_type = driver.entity_type_from_entity_id(entity_id)  # Returns \"media_player\"\n</code></pre> <p>Override only if you use a custom entity ID format (same conditions as <code>device_from_entity_id()</code>).</p>"},{"location":"guide/driver/#6-sub_device_from_entity_id-has-default","title":"6. sub_device_from_entity_id() \u2705 Has Default","text":"<p>Default behavior: Extracts sub-device ID from 3-part format <code>\"entity_type.device_id.sub_device_id\"</code>.</p> <pre><code># 2-part format returns None\nentity_id = \"media_player.receiver_123\"\nsub_device = driver.sub_device_from_entity_id(entity_id)  # Returns None\n\n# 3-part format returns the sub-device\nentity_id = \"light.hub_1.bedroom\"\nsub_device = driver.sub_device_from_entity_id(entity_id)  # Returns \"bedroom\"\n</code></pre> <p>Useful for hub-based integrations where one device exposes multiple entities.</p>"},{"location":"guide/driver/#7-get_entity_ids_for_device-has-default","title":"7. get_entity_ids_for_device() \u2705 Has Default","text":"<p>Default behavior: Queries the API for all entities (both available and configured) and filters by device ID.</p> <pre><code># Works automatically - no override needed\nentity_ids = driver.get_entity_ids_for_device(\"receiver_123\")\n# Returns [\"media_player.receiver_123\", \"remote.receiver_123\"]\n</code></pre> <p>Override only if you need performance optimization:</p> <pre><code>def __init__(self, loop):\n    super().__init__(...)\n    self._entity_cache: dict[str, list[str]] = {}\n\ndef get_entity_ids_for_device(self, device_id: str) -&gt; list[str]:\n    \"\"\"Cached entity lookup for performance.\"\"\"\n    if device_id not in self._entity_cache:\n        self._entity_cache[device_id] = [\n            f\"media_player.{device_id}\",\n            f\"remote.{device_id}\",\n        ]\n    return self._entity_cache[device_id]\n</code></pre>"},{"location":"guide/driver/#8-on_device_update-has-default","title":"8. on_device_update() \u2705 Has Default","text":"<p>Default behavior: Automatically extracts entity-type-specific attributes from the update dict and updates configured/available entities. Supports all entity types (Button, Climate, Cover, Light, Media Player, Remote, Sensor, Switch).</p> <pre><code># Works automatically - device sends update, entities get updated\ndevice.events.emit(DeviceEvents.UPDATE, device_id, {\n    \"state\": \"PLAYING\",\n    \"volume\": 50,\n    \"media_title\": \"Song Name\"\n})\n# Framework automatically updates the configured entity attributes\n</code></pre> <p>Special feature for media players: When state is <code>OFF</code>, all media attributes (title, artist, duration, etc.) are automatically cleared. Control this with the <code>clear_media_when_off</code> parameter.</p> <p>Override only if you need custom state mapping or attribute transformation:</p> <pre><code>async def on_device_update(\n    self, device_id: str, update: dict[str, Any] | None\n) -&gt; None:\n    \"\"\"Custom update handling with state transformation.\"\"\"\n    if update:\n        # Transform device-specific values before calling default\n        if \"power_state\" in update:\n            update[\"state\"] = \"ON\" if update[\"power_state\"] else \"OFF\"\n\n    await super().on_device_update(device_id, update)\n</code></pre>"},{"location":"guide/driver/#event-handlers","title":"Event Handlers","text":""},{"location":"guide/driver/#device-events","title":"Device Events","text":"<p>Override these to customize device event handling:</p> <pre><code>async def on_device_connected(self, device_id: str) -&gt; None:\n    \"\"\"Device connected.\"\"\"\n    await super().on_device_connected(device_id)\n    # Custom logic...\n\nasync def on_device_disconnected(self, device_id: str) -&gt; None:\n    \"\"\"Device disconnected.\"\"\"\n    await super().on_device_disconnected(device_id)\n    # Custom logic...\n\nasync def on_device_connection_error(\n    self, device_id: str, message: str\n) -&gt; None:\n    \"\"\"Device connection error.\"\"\"\n    await super().on_device_connection_error(device_id, message)\n    # Custom logic...\n\nasync def on_device_update(\n    self, device_id: str, update: dict[str, Any] | None,\n    clear_media_when_off: bool = True\n) -&gt; None:\n    \"\"\"Device state update.\"\"\"\n    # Default implementation handles all entity types\n    await super().on_device_update(device_id, update, clear_media_when_off)\n</code></pre>"},{"location":"guide/driver/#remote-events","title":"Remote Events","text":"<p>Override these to customize Remote Two event handling:</p> <pre><code>async def on_r2_connect_cmd(self) -&gt; None:\n    \"\"\"Remote connected.\"\"\"\n    # Custom pre-connect logic...\n    await super().on_r2_connect_cmd()\n\nasync def on_r2_disconnect_cmd(self) -&gt; None:\n    \"\"\"Remote disconnected.\"\"\"\n    await super().on_r2_disconnect_cmd()\n    # Custom cleanup...\n\nasync def on_r2_enter_standby(self) -&gt; None:\n    \"\"\"Remote entering standby.\"\"\"\n    await super().on_r2_enter_standby()\n    # Save power...\n\nasync def on_r2_exit_standby(self) -&gt; None:\n    \"\"\"Remote exiting standby.\"\"\"\n    await super().on_r2_exit_standby()\n    # Wake devices...\n</code></pre>"},{"location":"guide/driver/#hub-based-integrations","title":"Hub-Based Integrations","text":"<p>For integrations where entities are discovered dynamically from a hub device (like smart home bridges or multi-zone receivers), use the <code>require_connection_before_registry</code> flag:</p> <pre><code>class MyHubDriver(BaseIntegrationDriver[MyHub, MyHubConfig]):\n    def __init__(self):\n        super().__init__(\n            device_class=MyHub,\n            entity_classes=[EntityTypes.LIGHT, EntityTypes.SWITCH],\n            require_connection_before_registry=True  # Enable hub mode\n        )\n</code></pre>"},{"location":"guide/driver/#how-it-works","title":"How It Works","text":"<p>When <code>require_connection_before_registry=True</code>:</p> <ol> <li>Device Addition: Uses <code>async_add_configured_device()</code> which connects first, then registers entities</li> <li>Entity Subscription: Waits for connection before calling <code>async_register_available_entities()</code></li> <li>Entity Discovery: Entities are populated from the hub after connection</li> </ol>"},{"location":"guide/driver/#required-override","title":"Required Override","text":"<p>You must override <code>async_register_available_entities()</code> to populate entities from the hub:</p> <pre><code>async def async_register_available_entities(\n    self, device_config: MyHubConfig, device: MyHub\n) -&gt; None:\n    \"\"\"Register entities discovered from the hub.\"\"\"\n    # Get entities from connected hub\n    hub_devices = await device.get_discovered_devices()\n\n    for hub_device in hub_devices:\n        entity_id = create_entity_id(\n            EntityTypes.LIGHT, \n            device_config.identifier,\n            hub_device.id  # Sub-entity ID\n        )\n        entity = Light(\n            entity_id,\n            hub_device.name,\n            features=[light.Features.ON_OFF, light.Features.DIM]\n        )\n        self.api.available_entities.add(entity)\n</code></pre>"},{"location":"guide/driver/#entity-id-helpers-for-hubs","title":"Entity ID Helpers for Hubs","text":"<p>Use the 3-part entity ID format for hub devices:</p> <pre><code># Create entity ID with sub-device\nentity_id = create_entity_id(EntityTypes.LIGHT, \"hub_1\", \"bedroom_light\")\n# Result: \"light.hub_1.bedroom_light\"\n\n# Parse it back\ndevice_id = driver.device_from_entity_id(entity_id)  # \"hub_1\"\nentity_type = driver.entity_type_from_entity_id(entity_id)  # \"light\"\nsub_device = driver.sub_device_from_entity_id(entity_id)  # \"bedroom_light\"\n</code></pre>"},{"location":"guide/driver/#minimal-example","title":"Minimal Example","text":"<p>Most drivers work with just the defaults:</p> <pre><code>from ucapi_framework import BaseIntegrationDriver\nfrom ucapi import EntityTypes\n\nclass MyDriver(BaseIntegrationDriver[MyDevice, MyDeviceConfig]):\n    \"\"\"Simple integration driver - uses all defaults.\"\"\"\n\n    def __init__(self):\n        super().__init__(\n            device_class=MyDevice,\n            entity_classes=EntityTypes.MEDIA_PLAYER,  # Or list of types\n        )\n\n    # That's it! The framework handles:\n    # \u2705 Entity creation (one per entity_class)\n    # \u2705 State mapping (common state strings)\n    # \u2705 Entity ID parsing (standard format)\n    # \u2705 Device updates (all entity types)\n    # \u2705 Event propagation\n</code></pre>"},{"location":"guide/driver/#custom-example","title":"Custom Example","text":"<p>Override only what you need:</p> <pre><code>from ucapi_framework import BaseIntegrationDriver\nfrom ucapi import EntityTypes, media_player\n\nclass MyDriver(BaseIntegrationDriver[MyDevice, MyDeviceConfig]):\n    \"\"\"Custom driver with specific requirements.\"\"\"\n\n    def __init__(self):\n        super().__init__(\n            device_class=MyDevice,\n            entity_classes=[\n                EntityTypes.MEDIA_PLAYER,\n                EntityTypes.REMOTE,\n            ]\n        )\n\n    def map_device_state(self, device_state: Any) -&gt; media_player.States:\n        \"\"\"Custom state mapping for device-specific enums.\"\"\"\n        if isinstance(device_state, MyDeviceState):\n            match device_state:\n                case MyDeviceState.POWERED_ON:\n                    return media_player.States.ON\n                case MyDeviceState.POWERED_OFF:\n                    return media_player.States.OFF\n                case MyDeviceState.STREAMING:\n                    return media_player.States.PLAYING\n                case _:\n                    return super().map_device_state(device_state)\n        return super().map_device_state(device_state)\n\n    async def on_device_connected(self, device_id: str) -&gt; None:\n        \"\"\"Custom logic when device connects.\"\"\"\n        await super().on_device_connected(device_id)\n        # Send notification or update UI\n        _LOG.info(f\"Device {device_id} is now online!\")\n</code></pre> <p>See the API Reference for complete documentation of all methods and event handlers.</p>"},{"location":"guide/setup-flow/","title":"Setup Flow Guide","text":"<p>The setup flow handles user interaction during device configuration. It provides a standard flow with extension points for customization.</p>"},{"location":"guide/setup-flow/#creating-a-setup-handler","title":"Creating a Setup Handler","text":"<p>Create a setup handler by calling <code>create_handler()</code> on your setup flow class:</p> <pre><code>from ucapi_framework import BaseSetupFlow, BaseIntegrationDriver\n\n# Create your driver with optional driver_id for migration support\ndriver = MyDriver(\n    device_class=MyDevice,\n    entity_classes=[MediaPlayer],\n    driver_id=\"mydriver\"  # Optional: enables auto-fetch of current version during migration and thus is only needed if migration is supported\n)\n\n# Create setup handler - driver_id is automatically extracted from driver\ndiscovery = MyDiscovery(api_key=\"...\", timeout=30)\nsetup_handler = MySetupFlow.create_handler(driver, discovery=discovery)\n</code></pre> <p>Driver ID for Migration:</p> <p>The optional <code>driver_id</code> parameter on the <code>BaseIntegrationDriver</code> enables enhanced migration features:</p> <ul> <li>Without <code>driver_id</code>: Users must manually enter the current version during migration</li> <li>With <code>driver_id</code>: The framework automatically fetches the current version from the Remote using the integration's API</li> </ul> <p>This improves user experience during entity ID migrations by reducing the information users need to provide. See Entity ID Migration for details.</p>"},{"location":"guide/setup-flow/#overview","title":"Overview","text":"<p>The setup flow follows this pattern:</p> <pre><code>graph LR\n    A[Start Setup] --&gt; B{Reconfigure?}\n    B --&gt;|Yes| C[Configuration Mode]\n    B --&gt;|No| D[Restore Prompt]\n    D --&gt;|Restore| E[Restore Screen]\n    D --&gt;|Skip| F{Discovery?}\n    F --&gt;|Yes| G[Pre-Discovery Screen]\n    G --&gt; H[Run Discovery]\n    H --&gt; I[Device Selection]\n    F --&gt;|No| J[Manual Entry]\n    I --&gt; K[query_device]\n    J --&gt; K\n    K --&gt; L[Additional Config?]\n    L --&gt;|Yes| M[Additional Screen]\n    L --&gt;|No| N[Complete]\n    M --&gt; N\n    E --&gt; N\n</code></pre>"},{"location":"guide/setup-flow/#key-concept-unified-flow","title":"Key Concept: Unified Flow","text":"<p>Both discovery and manual entry paths converge on <code>query_device()</code>. This means you only implement device validation logic once:</p> <ul> <li>Manual entry \u2192 <code>query_device(input_values)</code></li> <li>Discovery selection \u2192 <code>prepare_input_from_discovery()</code> \u2192 <code>query_device(input_values)</code></li> </ul>"},{"location":"guide/setup-flow/#basic-setup-flow","title":"Basic Setup Flow","text":"<p>The simplest setup flow requires implementing <code>get_manual_entry_form()</code> and <code>query_device()</code>:</p> <pre><code>from ucapi_framework import BaseSetupFlow\nfrom ucapi.api_definitions import RequestUserInput\n\nclass MySetupFlow(BaseSetupFlow[MyDeviceConfig]):\n    \"\"\"Minimal setup flow.\"\"\"\n\n    def get_manual_entry_form(self) -&gt; RequestUserInput:\n        \"\"\"Define the manual entry form.\"\"\"\n        return RequestUserInput(\n            title=\"Add Device\",\n            settings=[\n                {\n                    \"id\": \"address\",\n                    \"label\": {\"en\": \"Device IP Address\"},\n                    \"field\": {\"text\": {\"value\": \"\"}},\n                },\n                {\n                    \"id\": \"name\",\n                    \"label\": {\"en\": \"Device Name\"},\n                    \"field\": {\"text\": {\"value\": \"\"}},\n                },\n            ],\n        )\n\n    async def query_device(self, input_values: dict) -&gt; MyDeviceConfig:\n        \"\"\"Create config from user input (works for both manual and discovery).\"\"\"\n        return MyDeviceConfig(\n            identifier=input_values.get(\"identifier\", input_values[\"address\"].replace(\".\", \"_\")),\n            name=input_values[\"name\"],\n            host=input_values[\"address\"],\n        )\n</code></pre>"},{"location":"guide/setup-flow/#extension-points","title":"Extension Points","text":""},{"location":"guide/setup-flow/#restore-prompt","title":"Restore Prompt","text":"<p>When a user starts initial setup (not reconfiguration), they are first asked if they want to restore from a backup. This is useful when upgrading integrations to allow users to import their previous configuration without having to set up a new device first.</p> <p>The default prompt asks: \"Are you upgrading this integration? If you have a configuration backup, you can restore it now. Otherwise, continue with the setup process to add a new device.\"</p> <p>You can customize this message:</p> <pre><code>async def get_restore_prompt_text(self) -&gt; str:\n    \"\"\"Customize the restore prompt message.\"\"\"\n    return (\n        \"Welcome to MyDevice Integration v2.0! \"\n        \"If you're upgrading from v1.x, you can restore your \"\n        \"previous configuration. Otherwise, continue with setup.\"\n    )\n</code></pre> <p>The restore prompt:</p> <ul> <li>Appears before any other setup screens during initial setup</li> <li>Shows a checkbox for \"Restore from backup\"</li> <li>If checked, goes directly to the restore screen</li> <li>If unchecked, continues with normal setup flow (pre-discovery \u2192 discovery \u2192 manual entry)</li> </ul> <p>This also appears when users select \"Reset\" in configuration mode, allowing them to restore after clearing their configuration.</p>"},{"location":"guide/setup-flow/#pre-discovery-screens","title":"Pre-Discovery Screens","text":"<p>Collect information before running discovery (API keys, server addresses, etc.):</p> <pre><code>async def get_pre_discovery_screen(self) -&gt; RequestUserInput | None:\n    \"\"\"Screen shown before discovery.\"\"\"\n    return RequestUserInput(\n        title=\"Authentication\",\n        settings=[\n            {\n                \"id\": \"api_key\",\n                \"label\": {\"en\": \"API Key\"},\n                \"field\": {\"text\": {\"value\": \"\"}},\n            },\n        ],\n    )\n\nasync def handle_pre_discovery_response(\n    self, msg: UserDataResponse\n) -&gt; SetupAction:\n    \"\"\"Process pre-discovery input.\"\"\"\n    # Data is automatically stored in self._pre_discovery_data\n    # and merged with manual entry input later\n\n    # Continue to discovery\n    return await self._handle_discovery()\n</code></pre>"},{"location":"guide/setup-flow/#discovery-to-input-conversion","title":"Discovery to Input Conversion","text":"<p>When a user selects a discovered device, override <code>prepare_input_from_discovery()</code> to convert the discovered device data to the same format as manual entry:</p> <pre><code>async def prepare_input_from_discovery(\n    self, discovered: DiscoveredDevice, additional_input: dict\n) -&gt; dict:\n    \"\"\"Convert discovered device to input_values format.\"\"\"\n    return {\n        \"identifier\": discovered.identifier,\n        \"address\": discovered.address,\n        \"name\": additional_input.get(\"name\", discovered.name),\n        \"port\": discovered.extra_data.get(\"port\", 8080),\n    }\n</code></pre> <p>The default implementation returns basic fields (<code>identifier</code>, <code>address</code>, <code>name</code>) plus any additional input fields.</p>"},{"location":"guide/setup-flow/#additional-configuration","title":"Additional Configuration","text":"<p>Collect device-specific settings after device selection:</p> <pre><code>async def get_additional_configuration_screen(\n    self, device_config: MyDeviceConfig, input_values: dict\n) -&gt; RequestUserInput | None:\n    \"\"\"Screen shown after query_device succeeds.\"\"\"\n    return RequestUserInput(\n        title=\"Device Settings\",\n        settings=[\n            {\n                \"id\": \"zone\",\n                \"label\": {\"en\": \"Zone\"},\n                \"field\": {\n                    \"dropdown\": {\n                        \"value\": \"main\",\n                        \"items\": [\n                            {\"id\": \"main\", \"label\": {\"en\": \"Main\"}},\n                            {\"id\": \"zone2\", \"label\": {\"en\": \"Zone 2\"}},\n                        ],\n                    }\n                },\n            },\n        ],\n    )\n\nasync def handle_additional_configuration_response(\n    self, msg: UserDataResponse\n) -&gt; SetupAction:\n    \"\"\"Process additional configuration.\"\"\"\n    # Fields are auto-populated to self._pending_device_config\n    # Just return None to save and complete\n    return None\n</code></pre>"},{"location":"guide/setup-flow/#custom-discovery-fields","title":"Custom Discovery Fields","text":"<p>Add extra fields to the discovery result screen:</p> <pre><code>def get_additional_discovery_fields(self) -&gt; list[dict]:\n    \"\"\"Add custom fields to discovery screen.\"\"\"\n    return [\n        {\n            \"id\": \"zone\",\n            \"label\": {\"en\": \"Zone\"},\n            \"field\": {\n                \"dropdown\": {\n                    \"value\": \"main\",\n                    \"items\": [\n                        {\"id\": \"main\", \"label\": {\"en\": \"Main Zone\"}},\n                        {\"id\": \"zone2\", \"label\": {\"en\": \"Zone 2\"}},\n                    ],\n                }\n            },\n        }\n    ]\n</code></pre> <p>These additional input values are passed to <code>prepare_input_from_discovery()</code>.</p>"},{"location":"guide/setup-flow/#device-validation-pattern","title":"Device Validation Pattern","text":"<p>The framework provides <code>self.device_class</code> to enable calling class methods for validation. This keeps validation logic with your device class and allows reuse in the device's <code>connect()</code> method.</p>"},{"location":"guide/setup-flow/#using-class-methods-for-validation","title":"Using Class Methods for Validation","text":"<p>Define a class method on your device for validation:</p> <pre><code>from ucapi_framework import StatelessHTTPDevice\nimport aiohttp\n\nclass MyDevice(StatelessHTTPDevice):\n    @classmethod\n    async def validate_connection(cls, host: str, token: str) -&gt; dict:\n        \"\"\"Validate connection and return device info.\n\n        This method can be called during setup without creating a device instance.\n        \"\"\"\n        async with aiohttp.ClientSession() as session:\n            async with session.get(\n                f\"http://{host}/api/info\",\n                headers={\"Authorization\": f\"Bearer {token}\"}\n            ) as resp:\n                if resp.status != 200:\n                    raise ConnectionError(f\"Connection failed: {resp.status}\")\n                return await resp.json()\n\n    async def connect(self):\n        \"\"\"Connect to device - can reuse validation logic.\"\"\"\n        try:\n            info = await self.validate_connection(\n                self._config.host,\n                self._config.token\n            )\n            self._model = info.get(\"model\")\n            self._firmware = info.get(\"firmware\")\n            return True\n        except ConnectionError:\n            return False\n</code></pre> <p>Then use it in your setup flow:</p> <pre><code>class MySetupFlow(BaseSetupFlow[MyDeviceConfig]):\n    async def query_device(self, input_values: dict):\n        \"\"\"Validate device using device class method.\"\"\"\n        try:\n            # self.device_class is available via the framework\n            info = await self.device_class.validate_connection(\n                host=input_values[\"host\"],\n                token=input_values[\"token\"]\n            )\n\n            return MyDeviceConfig(\n                identifier=info[\"device_id\"],\n                name=info.get(\"name\", input_values[\"name\"]),\n                host=input_values[\"host\"],\n                token=input_values[\"token\"],\n                model=info[\"model\"],\n                firmware=info[\"firmware\"]\n            )\n        except ConnectionError as e:\n            _LOG.error(\"Connection validation failed: %s\", e)\n            return SetupError(error_type=IntegrationSetupError.CONNECTION_REFUSED)\n</code></pre> <p>Benefits:</p> <ul> <li>\u2705 Validation logic stays with device class</li> <li>\u2705 Can be reused in <code>connect()</code> method</li> <li>\u2705 No device instance needed during setup</li> <li>\u2705 Type-safe and discoverable</li> <li>\u2705 Keeps setup flow clean and focused</li> </ul>"},{"location":"guide/setup-flow/#alternative-separate-api-client","title":"Alternative: Separate API Client","text":"<p>For complex APIs, you can also use a separate API client class:</p> <pre><code>class MyAPIClient:\n    \"\"\"Standalone API client for device communication.\"\"\"\n\n    async def get_device_info(self, host: str, token: str) -&gt; dict:\n        \"\"\"Get device information.\"\"\"\n        async with aiohttp.ClientSession() as session:\n            async with session.get(f\"http://{host}/api/info\") as resp:\n                return await resp.json()\n\n# In device:\nclass MyDevice(StatelessHTTPDevice):\n    def __init__(self, config):\n        super().__init__(config)\n        self._client = MyAPIClient()\n\n    async def connect(self):\n        info = await self._client.get_device_info(\n            self._config.host,\n            self._config.token\n        )\n        return info is not None\n\n# In setup:\nclass MySetupFlow(BaseSetupFlow):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._client = MyAPIClient()\n\n    async def query_device(self, input_values):\n        info = await self._client.get_device_info(\n            input_values[\"host\"],\n            input_values[\"token\"]\n        )\n        return MyDeviceConfig(...)\n</code></pre> <p>Both patterns work well - choose based on your preference and API complexity.</p>"},{"location":"guide/setup-flow/#multi-screen-flows","title":"Multi-Screen Flows","text":"<p>For complex setups requiring multiple screens:</p> <pre><code>async def query_device(self, input_values: dict) -&gt; MyDeviceConfig | RequestUserInput:\n    \"\"\"Query device and optionally show more screens.\"\"\"\n    # Test connection\n    device_info = await self._api.get_device_info(input_values[\"address\"])\n\n    if not device_info:\n        return SetupError(error_type=IntegrationSetupError.CONNECTION_REFUSED)\n\n    # Store config for multi-screen flow\n    self._pending_device_config = MyDeviceConfig(\n        identifier=device_info[\"id\"],\n        name=input_values[\"name\"],\n        address=input_values[\"address\"],\n    )\n\n    # Show additional screen\n    return RequestUserInput(\n        {\"en\": \"Select Options\"},\n        [{\"id\": \"option\", \"label\": {\"en\": \"Option\"}, \n          \"field\": {\"text\": {\"value\": \"\"}}}]\n    )\n</code></pre>"},{"location":"guide/setup-flow/#configuration-modes","title":"Configuration Modes","text":"<p>The setup flow handles three configuration modes automatically:</p> <ul> <li>ADD - Add a new device</li> <li>REMOVE - Remove an existing device</li> <li>RESET - Clear all devices and configuration</li> </ul>"},{"location":"guide/setup-flow/#backup-restore","title":"Backup &amp; Restore","text":"<p>Backup and restore are automatically handled by the framework. Users can:</p> <ul> <li>Export configuration as JSON</li> <li>Import configuration from JSON</li> </ul>"},{"location":"guide/setup-flow/#entity-id-migration","title":"Entity ID Migration","text":"<p>When you release a new version of your integration that changes entity ID formats, you can implement migration support to automatically update entity references in the Remote's activities, button mappings, and UI pages.</p>"},{"location":"guide/setup-flow/#when-to-use-migration","title":"When to Use Migration","text":"<p>Implement migration when:</p> <ul> <li>Entity ID format changes - You switch from one naming scheme to another (e.g., <code>media_player.device</code> \u2192 <code>player.device</code>)</li> <li>Entity type renames - Your entity types are renamed (e.g., <code>av_receiver</code> \u2192 <code>media_player</code>)</li> <li>Driver ID changes - Your integration's driver ID changes between versions</li> </ul>"},{"location":"guide/setup-flow/#implementing-migration","title":"Implementing Migration","text":"<p>To enable migration, implement two methods in your setup flow:</p>"},{"location":"guide/setup-flow/#1-is_migration_required","title":"1. is_migration_required()","text":"<p>Check if migration is needed based on the previous version:</p> <pre><code>async def is_migration_required(self, previous_version: str) -&gt; bool:\n    \"\"\"Check if migration is needed from the previous version.\"\"\"\n    # Parse version and determine if migration is needed\n    # For example, migration needed from v1.x to v2.x\n    if previous_version.startswith(\"1.\"):\n        return True\n    return False\n</code></pre>"},{"location":"guide/setup-flow/#2-get_migration_data","title":"2. get_migration_data()","text":"<p>Generate the entity ID mappings:</p> <pre><code>async def get_migration_data(\n    self, previous_version: str, current_version: str\n) -&gt; MigrationData:\n    \"\"\"Generate entity ID mappings for migration.\n\n    Returns:\n        MigrationData with driver IDs and entity mappings\n    \"\"\"\n    from ucapi_framework.migration import MigrationData, EntityMigrationMapping\n\n    mappings: list[EntityMigrationMapping] = []\n\n    # Iterate through all configured devices\n    for device in self.config.all():\n        # Example: Old format was \"media_player.{device_id}\"\n        # New format is \"player.{device_id}\"\n        mappings.append({\n            \"previous_entity_id\": f\"media_player.{device.identifier}\",\n            \"new_entity_id\": f\"player.{device.identifier}\"\n        })\n\n        # Example: Light entity rename\n        mappings.append({\n            \"previous_entity_id\": f\"light.{device.identifier}\",\n            \"new_entity_id\": f\"light.{device.identifier}_main\"\n        })\n\n    return {\n        \"previous_driver_id\": \"myintegration_v1\",\n        \"new_driver_id\": \"myintegration_v2\",\n        \"entity_mappings\": mappings\n    }\n</code></pre>"},{"location":"guide/setup-flow/#migration-data-format","title":"Migration Data Format","text":"<p>The <code>MigrationData</code> dictionary has three fields:</p> <pre><code>{\n    \"previous_driver_id\": str,  # Old driver ID (without .main suffix)\n    \"new_driver_id\": str,       # New driver ID (without .main suffix)\n    \"entity_mappings\": [        # List of entity ID changes\n        {\n            \"previous_entity_id\": str,  # Old entity ID (without driver prefix)\n            \"new_entity_id\": str        # New entity ID (without driver prefix)\n        }\n    ]\n}\n</code></pre> <p>Important Notes:</p> <ul> <li>Driver IDs: Specify WITHOUT the <code>.main</code> suffix. The framework automatically appends <code>.main</code> to create the integration_id used by the Remote API.</li> <li>Entity IDs: Specify WITHOUT the driver_id/integration_id prefix. Just the entity type and device identifier (e.g., <code>\"media_player.tv\"</code>, not <code>\"mydriver.main.media_player.tv\"</code>).</li> <li>Full Entity IDs: The Remote uses the format <code>integration_id.entity_id</code> where <code>integration_id = driver_id + \".main\"</code>.</li> <li>Automatic Migration: When a user goes through the setup flow and migration is required, the framework will:</li> <li>Call <code>is_migration_required()</code> to check if migration is needed</li> <li>Prompt for previous version, Remote URL, and PIN</li> <li>If your driver has <code>driver_id</code> set (via <code>BaseIntegrationDriver.__init__()</code>), automatically fetch the current version from the Remote</li> <li>If driver doesn't have <code>driver_id</code> set, prompt the user to enter the current version manually</li> <li>Call <code>get_migration_data()</code> to get entity mappings</li> <li>Automatically call <code>migrate_entities_on_remote()</code> to perform the migration</li> <li>Display success/failure results</li> </ul> <p>Automatic Version Fetching:</p> <p>When you create the driver with a <code>driver_id</code>:</p> <pre><code>driver = MyDriver(\n    device_class=MyDevice,\n    entity_classes=[MediaPlayer],\n    driver_id=\"mydriver\"  # Enables automatic version fetching\n)\n</code></pre> <p>The framework can automatically fetch the current version from the Remote during migration, eliminating the need for users to manually enter it. This requires:</p> <ul> <li>The integration is already installed on the Remote (so the driver_id exists)</li> <li>The user provides the Remote URL and PIN</li> <li>The Remote API is accessible</li> </ul> <p>If automatic fetching fails (e.g., Remote unreachable, driver not found), the user will be re-prompted to enter the current version manually.</p>"},{"location":"guide/setup-flow/#migration-example-version-upgrade","title":"Migration Example: Version Upgrade","text":"<p>Here's a complete example for migrating from v1.x to v2.x:</p> <pre><code>from ucapi_framework import BaseSetupFlow\nfrom ucapi_framework.migration import MigrationData\n\nclass MySetupFlow(BaseSetupFlow[MyDeviceConfig]):\n\n    async def is_migration_required(self, previous_version: str) -&gt; bool:\n        \"\"\"Migration needed from v1.x to v2.x.\"\"\"\n        try:\n            major_version = int(previous_version.split(\".\")[0])\n            return major_version &lt; 2\n        except (ValueError, IndexError):\n            return False\n\n    async def get_migration_data(\n        self, previous_version: str, current_version: str\n    ) -&gt; MigrationData:\n        \"\"\"Migrate entity IDs from v1 to v2 format.\"\"\"\n        from ucapi_framework.migration import EntityMigrationMapping\n\n        _LOG.info(\"Migrating from %s to %s\", previous_version, current_version)\n\n        mappings: list[EntityMigrationMapping] = []\n\n        for device in self.config.all():\n            # V1 used underscore separator, V2 uses dot separator\n            device_id = device.identifier\n\n            # Map old media_player entities\n            mappings.append({\n                \"previous_entity_id\": f\"media_player_{device_id}\",\n                \"new_entity_id\": f\"media_player.{device_id}\"\n            })\n\n            # Map old light entities\n            if device.has_lights:\n                mappings.append({\n                    \"previous_entity_id\": f\"light_{device_id}\",\n                    \"new_entity_id\": f\"light.{device_id}\"\n                })\n\n            _LOG.debug(\"Created %d mappings for device %s\", 2, device.name)\n\n        return {\n            \"previous_driver_id\": \"myintegration\",  # Same driver ID\n            \"new_driver_id\": \"myintegration\",       # Just entity format changed\n            \"entity_mappings\": mappings\n        }\n</code></pre>"},{"location":"guide/setup-flow/#migration-with-driver-id-changes","title":"Migration with Driver ID Changes","text":"<p>If your driver ID changes between versions:</p> <pre><code>async def get_migration_data(\n    self, previous_version: str, current_version: str\n) -&gt; MigrationData:\n    \"\"\"Migrate with driver ID change.\"\"\"\n    mappings = []\n\n    for device in self.config.all():\n        # Entity IDs stay the same, but driver changed\n        mappings.append({\n            \"previous_entity_id\": f\"media_player.{device.identifier}\",\n            \"new_entity_id\": f\"media_player.{device.identifier}\"  # Same!\n        })\n\n    return {\n        \"previous_driver_id\": \"old_integration_name\",\n        \"new_driver_id\": \"new_integration_name\",\n        \"entity_mappings\": mappings\n    }\n</code></pre>"},{"location":"guide/setup-flow/#using-migrate_entities_on_remote","title":"Using migrate_entities_on_remote()","text":"<p>For advanced use cases, you can programmatically trigger migration on the Remote:</p> <pre><code>from ucapi_framework.migration import migrate_entities_on_remote\n\n# In your integration code\nmigration_data = await setup_flow.get_migration_data(\"1.0.0\", \"2.0.0\")\n\nsuccess = await migrate_entities_on_remote(\n    remote_url=\"http://192.168.1.100\",\n    migration_data=migration_data,\n    pin=\"1234\"  # or api_key=\"your-api-key\"\n)\n\nif success:\n    _LOG.info(\"Migration completed successfully\")\nelse:\n    _LOG.error(\"Migration failed\")\n</code></pre> <p>This function:</p> <ol> <li>Fetches all activities from the Remote</li> <li>Filters activities using entities from the old integration</li> <li>Replaces entity IDs in all locations (included_entities, button_mapping, UI pages, sequences)</li> <li>Updates each activity via the Remote API</li> </ol>"},{"location":"guide/setup-flow/#testing-migration","title":"Testing Migration","text":"<p>Test your migration logic thoroughly:</p> <pre><code>async def test_migration():\n    \"\"\"Test migration mappings.\"\"\"\n    setup_flow = MySetupFlow(config_manager)\n\n    # Check if migration is required\n    assert await setup_flow.is_migration_required(\"1.5.0\") is True\n    assert await setup_flow.is_migration_required(\"2.0.0\") is False\n\n    # Test migration data\n    migration_data = await setup_flow.get_migration_data(\"1.5.0\", \"2.0.0\")\n\n    assert migration_data[\"previous_driver_id\"] == \"myintegration\"\n    assert migration_data[\"new_driver_id\"] == \"myintegration\"\n    assert len(migration_data[\"entity_mappings\"]) &gt; 0\n\n    # Verify specific mappings\n    first_mapping = migration_data[\"entity_mappings\"][0]\n    assert first_mapping[\"previous_entity_id\"] == \"media_player_device1\"\n    assert first_mapping[\"new_entity_id\"] == \"media_player.device1\"\n</code></pre> <p>Testing Mode (Development Only):</p> <p>For integration testing without making actual changes to the Remote, you can enable testing mode:</p> <pre><code># In your integration's setup handler creation\nsetup_handler = MySetupFlow.create_handler(\n    driver,\n    discovery=discovery,\n    migration_testing_mode=True  # Skip PATCH calls during migration\n)\n</code></pre> <p>When <code>migration_testing_mode=True</code>:</p> <ul> <li>All migration logic executes normally (fetching activities, replacing entity IDs, building payloads)</li> <li>PATCH calls to the Remote are skipped - no actual updates are made</li> <li>Log messages show what would be sent (for debugging)</li> <li>Useful for testing migration flow without affecting Remote state</li> </ul> <p>Important: This is a temporary testing feature and should only be enabled during development. Always set to <code>False</code> (or omit) for production releases.</p>"},{"location":"guide/setup-flow/#migration-best-practices","title":"Migration Best Practices","text":"<ol> <li>Test thoroughly: Migration affects user configurations - test all entity ID changes</li> <li>Log clearly: Use logging to track migration progress and issues</li> <li>Document changes: Inform users about entity ID changes in release notes</li> <li>Version check: Only require migration for versions that actually changed entity formats</li> <li>Handle edge cases: Consider devices with special characters, multiple zones, etc.</li> <li>Preserve functionality: Ensure migrated entities work correctly after migration</li> </ol>"},{"location":"guide/setup-flow/#complete-example","title":"Complete Example","text":"<p>See the API Reference for complete documentation of all methods and extension points.</p>"}]}